{
    "docs": [
        {
            "location": "/",
            "text": "ReactiveProperty documentation\n\n\nReactiveProperty provides MVVM and asynchronous support features under Reactive Extensions. Target framework is .NET 4.6, UWP, Xamarin.iOS, Xamarin.Android, Xamarin.Mac, Xamarin.Forms and .NET Standard 1.3.\n\n\n\n\nConcept of ReactiveProperty is \nFun the programing.\n\nYou can write MVVM pattern program using ReactiveProperty very fun.\n\n\n\n\nFollowing code is tow way binding between ReactiveProperty and plane object property.\n\n\nclass Model : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string _name;\n    public string Name\n    {\n        get => _name;\n        set\n        {\n            _name = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n        }\n    }\n}\nclass ViewModel\n{\n    private readonly Model _model = new Model();\n    public ReactiveProperty<string> Name { get; }\n    public ViewModel()\n    {\n        // TwoWay synchronize to ReactiveProperty and Model#Name property.\n        Name = _model.ToReactivePropertyAsSynchronized(x => x.Name);\n    }\n}\n\n\n\n\nReactiveProperty is implemented the IObservable<T>. Yes! You can use the LINQ.\n\n\nvar name = new ReactiveProperty<string>();\nname.Where(x => x.StartsWith(\"_\")) // filter\n    .Select(x => x.ToUpper()) // convert\n    .Subscribe(x => { ... some action ... });\n\n\n\n\nReactiveProperty is created from IObservable<T>. \n\n\nclass ViewModel\n{\n    public ReactiveProperty<string> Input { get; }\n    public ReactiveProperty<string> Output { get; }\n\n    public ViewModel()\n    {\n        Input = new ReactiveProperty(\"\");\n        Output = Input\n            .Delay(TimeSpan.FromSecond(1)) // Using a Rx method.\n            .Select(x => x.ToUpper()) // Using a LINQ method.\n            .ToReactiveProperty(); // Convert to ReactiveProperty\n    }\n}\n\n\n\n\nI think that this method chain is very cool.\n\n\nAnd we provide the ReactiveCommand class what implements ICommand and IObservable<T> interface. ReactiveCommand can create from IObservable<bool>\n\n\nvar command = Observable.Interval(TimeSpan.FromSecond(1))\n    .Select(x => x % 2 == 0) // convert to IO<bool>\n    .ToReactiveCommand();\ncommand.Subscribe(_ =>\n{\n    // ReactiveCommand invoke an OnNext when Execute method was called.\n});\n\n\n\n\nYou can start the ReactiveProperty from following links.\n\n\n\n\nGetting started\n\n\nWPF\n\n\nUWP\n\n\nXamarin.Forms",
            "title": "ReactiveProperty documentation"
        },
        {
            "location": "/#reactiveproperty-documentation",
            "text": "ReactiveProperty provides MVVM and asynchronous support features under Reactive Extensions. Target framework is .NET 4.6, UWP, Xamarin.iOS, Xamarin.Android, Xamarin.Mac, Xamarin.Forms and .NET Standard 1.3.   Concept of ReactiveProperty is  Fun the programing. \nYou can write MVVM pattern program using ReactiveProperty very fun.   Following code is tow way binding between ReactiveProperty and plane object property.  class Model : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string _name;\n    public string Name\n    {\n        get => _name;\n        set\n        {\n            _name = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n        }\n    }\n}\nclass ViewModel\n{\n    private readonly Model _model = new Model();\n    public ReactiveProperty<string> Name { get; }\n    public ViewModel()\n    {\n        // TwoWay synchronize to ReactiveProperty and Model#Name property.\n        Name = _model.ToReactivePropertyAsSynchronized(x => x.Name);\n    }\n}  ReactiveProperty is implemented the IObservable<T>. Yes! You can use the LINQ.  var name = new ReactiveProperty<string>();\nname.Where(x => x.StartsWith(\"_\")) // filter\n    .Select(x => x.ToUpper()) // convert\n    .Subscribe(x => { ... some action ... });  ReactiveProperty is created from IObservable<T>.   class ViewModel\n{\n    public ReactiveProperty<string> Input { get; }\n    public ReactiveProperty<string> Output { get; }\n\n    public ViewModel()\n    {\n        Input = new ReactiveProperty(\"\");\n        Output = Input\n            .Delay(TimeSpan.FromSecond(1)) // Using a Rx method.\n            .Select(x => x.ToUpper()) // Using a LINQ method.\n            .ToReactiveProperty(); // Convert to ReactiveProperty\n    }\n}  I think that this method chain is very cool.  And we provide the ReactiveCommand class what implements ICommand and IObservable<T> interface. ReactiveCommand can create from IObservable<bool>  var command = Observable.Interval(TimeSpan.FromSecond(1))\n    .Select(x => x % 2 == 0) // convert to IO<bool>\n    .ToReactiveCommand();\ncommand.Subscribe(_ =>\n{\n    // ReactiveCommand invoke an OnNext when Execute method was called.\n});  You can start the ReactiveProperty from following links.   Getting started  WPF  UWP  Xamarin.Forms",
            "title": "ReactiveProperty documentation"
        },
        {
            "location": "/features/ReactiveCommandClass/",
            "text": "ReactiveCommand class\n\n\nThis class implements following two interfaces.\n- ICommand interface\n- IObservable<T>\n\n\nBasic usage\n\n\nThis class can be created using the ToReactiveCommand extension method from IObservable<bool> instance.\nWhen the IObservable<bool> instance updated, the CanExecuteChanged event raise.\n\n\nIf you want an always executable command, then you can create ReactiveCommand instance using the default constructor.\n\n\nIObservable<bool> canExecuteSource = ...;\n\nReactiveCommand someCommand = canExecuteSource.ToReactiveCommand(); // non command parameter version.\nReactiveCommand<string> hasCommandParameterCommand = canExecuteSource.ToReactiveCommand<string>(); // has command parameter version\nReactiveCommand alwaysExecutableCommand = new ReactiveCommand(); // non command parameter and always can execute version.\nReactiveCommand<string> alwaysExecutableAndHasCommandParameterCommand = new ReactiveCommand<string>(); // has command parameter and always can execute version.\n\n\n\n\nAnd you can set the initial return value of CanExecute method using factory extension method's initalValue argument.\nThe default value is true.\n\n\nIObservable<bool> canExecuteSource = ...;\n\nReactiveCommand someCommand = canExecuteSource.ToReactiveCommand(false);\nReactiveCommand<string> hasCommandParameterCommand = canExecuteSource.ToReactiveCommand<string>(false);\n\n\n\n\nWhen the Execute method is called, ReactiveCommand call an OnNext callback.\nYou can register the execute logic using the Subscribe method.\n\n\nReactiveCommand someCommand = new ReactiveCommand();\nsomeCommand.Subscribe(_ => { ... some logic ... }); // set an OnNext callback\n\nsomeCommand.Execute(); // OnNext callback is called.\n\n\n\n\nUsing in the ViewModel class\n\n\nThe first example, just use a ReactiveCommand class.\n\n\npublic class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = new ReactiveProperty<string>();\n        UpdateTimeCommand = new ReactiveCommand();\n        UpdateTimeCommand.Subscribe(_ => Time.Value = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"));\n    }\n}\n\n\n\n\nThe UWP platform example.\n\n\npublic sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"Update the time\"\n                Command=\"{x:Bind ViewModel.UpdateTimeCommand}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Time.Value, Mode=OneWay}\"\n                   Style=\"{ThemeResource BodyTextBlockStyle}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Page>\n\n\n\n\n\n\nWork with LINQ\n\n\nThe ReactiveCommand class implements IObservable<T> interface. \nCan use LINQ methods, and the ReactiveProperty<T> class can create from an IObservable<T>.\nYes, can change the previous example code to the below.\n\n\npublic class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    // Don't need that set the Value property. So can change to the ReadOnlyReactiveProperty.\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        UpdateTimeCommand = new ReactiveCommand();\n        Time = UpdateTimeCommand\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveProperty();\n    }\n}\n\n\n\n\nCreate from IObservable<bool>\n\n\nChange to that the UpdateTimeCommand don't invoke during 5 secs after the command invoked.\n\n\npublic class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        var updateTimeTrigger = new Subject<Unit>();\n        UpdateTimeCommand = Observable.Merge(\n            updateTimeTrigger.Select(_ => false),\n            updateTimeTrigger.Delay(TimeSpan.FromSeconds(5)).Select(_ => true))\n            .ToReactiveCommand();\n        Time = UpdateTimeCommand\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .Do(_ => updateTimeTrigger.OnNext(Unit.Default))\n            .ToReadOnlyReactiveProperty();\n    }\n}\n\n\n\n\n\n\nCreate a command and subscribe, in one statement\n\n\nIn the case that doesn't use LINQ methods, can create a command and subscribe, in one statement.\nThe WithSubscribe extension method subscribe and return the ReactiveCommand instance, see below.\n\n\npublic class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = new ReactiveProperty<string>();\n\n        var updateTimeTrigger = new Subject<Unit>();\n        UpdateTimeCommand = Observable.Merge(\n            updateTimeTrigger.Select(_ => false),\n            updateTimeTrigger.Delay(TimeSpan.FromSeconds(5)).Select(_ => true))\n            .ToReactiveCommand()\n            .WithSubscribe(() => Time.Value = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\")); // here\n    }\n}\n\n\n\n\nThis is a just shortcut the below code.\n\n\n// No use the WithSubscribe\nvar command = new ReactiveCommand();\ncommand.Subscribe(_ => { ... some actions ... });\n\n// Use the WithSubscribe\nvar command = new ReactiveCommand()\n    .WithSubscribe(() => { ... some actions ... });\n\n\n\n\nIf use LINQ methods, then separate statements create an instance and subscribe an onNext.\n\n\nUnsubscribe actions\n\n\nIf need that unsubscribes actions, then use the Dispose method of IDisposable which Subscribe method returned.\n\n\nvar command = new ReactiveCommand();\nvar subscription1 = command.Subscribe(_ => { ... some actions ... });\nvar subscription2 = command.Subscribe(_ => { ... some actions ... });\n\n// Unsubscribe per Subscribe method.\nsubscription1.Dispose();\nsubscription2.Dispose();\n\n// Unsubscribe all\ncommand.Dispose();\n\n\n\n\nThe WithSubscribe extension method have override methods which have IDisposable argument.\n\n\nIDisposable subscription = null;\nvar command = new ReactiveCommand().WithSubscribe(() => { ... some action ... }, out subscription);\n\n// Unsubscribe\nsubscription.Dispose();\n\n\n\n\nAnd has an override of Action\n argument.\nIt is used together with the CompositeDisposable class.\n\n\nvar subscriptions = new CompositeDisposable();\nvar command = new ReactiveCommand()\n    .WithSubscribe(() => { ... some actions ... }, subscriptions.Add)\n    .WithSubscribe(() => { ... some actions ... }, subscriptions.Add);\n\n// Unsubscribe\nsubscription.Dispose();\n\n\n\n\nIn other instance's events subscribe, then you should call the Dispose method of the ReactiveCommand class when the end of ViewModel lifecycle.",
            "title": "ReactiveCommand class"
        },
        {
            "location": "/features/ReactiveCommandClass/#reactivecommand-class",
            "text": "This class implements following two interfaces.\n- ICommand interface\n- IObservable<T>",
            "title": "ReactiveCommand class"
        },
        {
            "location": "/features/ReactiveCommandClass/#basic-usage",
            "text": "This class can be created using the ToReactiveCommand extension method from IObservable<bool> instance.\nWhen the IObservable<bool> instance updated, the CanExecuteChanged event raise.  If you want an always executable command, then you can create ReactiveCommand instance using the default constructor.  IObservable<bool> canExecuteSource = ...;\n\nReactiveCommand someCommand = canExecuteSource.ToReactiveCommand(); // non command parameter version.\nReactiveCommand<string> hasCommandParameterCommand = canExecuteSource.ToReactiveCommand<string>(); // has command parameter version\nReactiveCommand alwaysExecutableCommand = new ReactiveCommand(); // non command parameter and always can execute version.\nReactiveCommand<string> alwaysExecutableAndHasCommandParameterCommand = new ReactiveCommand<string>(); // has command parameter and always can execute version.  And you can set the initial return value of CanExecute method using factory extension method's initalValue argument.\nThe default value is true.  IObservable<bool> canExecuteSource = ...;\n\nReactiveCommand someCommand = canExecuteSource.ToReactiveCommand(false);\nReactiveCommand<string> hasCommandParameterCommand = canExecuteSource.ToReactiveCommand<string>(false);  When the Execute method is called, ReactiveCommand call an OnNext callback.\nYou can register the execute logic using the Subscribe method.  ReactiveCommand someCommand = new ReactiveCommand();\nsomeCommand.Subscribe(_ => { ... some logic ... }); // set an OnNext callback\n\nsomeCommand.Execute(); // OnNext callback is called.",
            "title": "Basic usage"
        },
        {
            "location": "/features/ReactiveCommandClass/#using-in-the-viewmodel-class",
            "text": "The first example, just use a ReactiveCommand class.  public class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = new ReactiveProperty<string>();\n        UpdateTimeCommand = new ReactiveCommand();\n        UpdateTimeCommand.Subscribe(_ => Time.Value = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"));\n    }\n}  The UWP platform example.  public sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"Update the time\"\n                Command=\"{x:Bind ViewModel.UpdateTimeCommand}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Time.Value, Mode=OneWay}\"\n                   Style=\"{ThemeResource BodyTextBlockStyle}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Page>",
            "title": "Using in the ViewModel class"
        },
        {
            "location": "/features/ReactiveCommandClass/#work-with-linq",
            "text": "The ReactiveCommand class implements IObservable<T> interface. \nCan use LINQ methods, and the ReactiveProperty<T> class can create from an IObservable<T>.\nYes, can change the previous example code to the below.  public class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    // Don't need that set the Value property. So can change to the ReadOnlyReactiveProperty.\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        UpdateTimeCommand = new ReactiveCommand();\n        Time = UpdateTimeCommand\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveProperty();\n    }\n}",
            "title": "Work with LINQ"
        },
        {
            "location": "/features/ReactiveCommandClass/#create-from-iobservablebool",
            "text": "Change to that the UpdateTimeCommand don't invoke during 5 secs after the command invoked.  public class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        var updateTimeTrigger = new Subject<Unit>();\n        UpdateTimeCommand = Observable.Merge(\n            updateTimeTrigger.Select(_ => false),\n            updateTimeTrigger.Delay(TimeSpan.FromSeconds(5)).Select(_ => true))\n            .ToReactiveCommand();\n        Time = UpdateTimeCommand\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .Do(_ => updateTimeTrigger.OnNext(Unit.Default))\n            .ToReadOnlyReactiveProperty();\n    }\n}",
            "title": "Create from IObservable&lt;bool&gt;"
        },
        {
            "location": "/features/ReactiveCommandClass/#create-a-command-and-subscribe-in-one-statement",
            "text": "In the case that doesn't use LINQ methods, can create a command and subscribe, in one statement.\nThe WithSubscribe extension method subscribe and return the ReactiveCommand instance, see below.  public class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = new ReactiveProperty<string>();\n\n        var updateTimeTrigger = new Subject<Unit>();\n        UpdateTimeCommand = Observable.Merge(\n            updateTimeTrigger.Select(_ => false),\n            updateTimeTrigger.Delay(TimeSpan.FromSeconds(5)).Select(_ => true))\n            .ToReactiveCommand()\n            .WithSubscribe(() => Time.Value = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\")); // here\n    }\n}  This is a just shortcut the below code.  // No use the WithSubscribe\nvar command = new ReactiveCommand();\ncommand.Subscribe(_ => { ... some actions ... });\n\n// Use the WithSubscribe\nvar command = new ReactiveCommand()\n    .WithSubscribe(() => { ... some actions ... });  If use LINQ methods, then separate statements create an instance and subscribe an onNext.",
            "title": "Create a command and subscribe, in one statement"
        },
        {
            "location": "/features/ReactiveCommandClass/#unsubscribe-actions",
            "text": "If need that unsubscribes actions, then use the Dispose method of IDisposable which Subscribe method returned.  var command = new ReactiveCommand();\nvar subscription1 = command.Subscribe(_ => { ... some actions ... });\nvar subscription2 = command.Subscribe(_ => { ... some actions ... });\n\n// Unsubscribe per Subscribe method.\nsubscription1.Dispose();\nsubscription2.Dispose();\n\n// Unsubscribe all\ncommand.Dispose();  The WithSubscribe extension method have override methods which have IDisposable argument.  IDisposable subscription = null;\nvar command = new ReactiveCommand().WithSubscribe(() => { ... some action ... }, out subscription);\n\n// Unsubscribe\nsubscription.Dispose();  And has an override of Action  argument.\nIt is used together with the CompositeDisposable class.  var subscriptions = new CompositeDisposable();\nvar command = new ReactiveCommand()\n    .WithSubscribe(() => { ... some actions ... }, subscriptions.Add)\n    .WithSubscribe(() => { ... some actions ... }, subscriptions.Add);\n\n// Unsubscribe\nsubscription.Dispose();  In other instance's events subscribe, then you should call the Dispose method of the ReactiveCommand class when the end of ViewModel lifecycle.",
            "title": "Unsubscribe actions"
        },
        {
            "location": "/features/ReactivePropertyClass/",
            "text": "ReactiveProperty class\n\n\nReactiveProperty is core class of this library.\nThis has following features.\n\n\n\n\nImplements the INotifyPropretyChanged interface.\n\n\nThe value property raise the PropertyChanged event.\n\n\n\n\n\n\nImplements the IObservable<T> interface.\n\n\n\n\nYes, The value property can bind to XAML control's property.\nAnd the class call the IObserver<T>#OnNext method when set the value.\n\n\nA sample code is below.\n\n\nusing Reactive.Bindings;\nusing System;\n\nnamespace ReactivePropertyEduApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // create from defualt constructor(default value is null)\n            var name = new ReactiveProperty<string>();\n            // setup the event handler and the onNext callback.\n            name.PropertyChanged += (_, e) => Console.WriteLine($\"PropertyChanged: {e.PropertyName}\");\n            name.Subscribe(x => Console.WriteLine($\"OnNext: {x}\"));\n\n            // update the value property.\n            name.Value = \"neuecc\";\n            name.Value = \"xin9le\";\n            name.Value = \"okazuki\";\n        }\n    }\n}\n\n\n\n\nThe output of this program is below.\n\n\nOnNext:\nOnNext: neuecc\nPropertyChanged: Value\nOnNext: xin9le\nPropertyChanged: Value\nOnNext: okazuki\nPropertyChanged: Value\n\n\n\n\nWhat's deferent between PropertyChanged and onNext callback?\nThe onNext is called when subscribe. The PropertyChanged isn't called when added the event handler. And the onNext callback's argument is the property value, the PropertyChanged argument don't have the property value.\n\n\nThe PropertyChanged event was provided for the data binding. In the normal case, you should use the Reactive Extensions methods.\n\n\nUse with the XAML platform\n\n\nThe ReactiveProperty class is designed for the XAML platform which is like WPF, UWP, and Xamarin.Forms.\nThis class can be used the ViewModel layer. \n\n\nIn the case that don't use the ReactiveProperty, the ViewModel class wrote the below. \n\n\npublic class MainPageViewModel : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string _name;\n    public string Name\n    {\n        get => _name;\n        set\n        {\n            _name = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n        }\n    }\n\n    // Other properties are defined similar codes.\n}\n\n\n\n\nAnd those properties binds in the XAML code.\n\n\n<!-- In the WPF -->\n<TextBox Text=\"{Binding Name}\" />\n\n<!-- In the UWP(Runtime data binding) -->\n<TextBox Text=\"{Binding Name}\" />\n\n<!-- In the UWP(Compile time data binding) -->\n<TextBox Text=\"{x:Bind ViewModel.Name, Mode=TwoWay}\" />\n\n<!-- In the Xamarin.Forms -->\n<Entry Text=\"{Binding Name}\" />\n\n\n\n\nIn the case that uses the ReactiveProperty, The ViewModel code becomes very simple!\n\n\n// The INotifyPropertyChanged interface must implement when using the WPF.\n// Because, if you don't implement this, then memory leak occurred.\npublic class MainPageViewModel\n{\n    public ReactiveProperty<string> Name { get; } = new ReactiveProperty<string>();\n\n    // Other properties are defined similar codes.\n}\n\n\n\n\nWhen binding in the XAML code, you must add the \n.Value\n in the binding path.\nThis is an only limitation of this library.\n\n\n<!-- In the WPF -->\n<TextBox Text=\"{Binding Name.Value}\" />\n\n<!-- In the UWP(Runtime data binding) -->\n<TextBox Text=\"{Binding Name}.Value\" />\n\n<!-- In the UWP(Compile time data binding) -->\n<TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay}\" />\n\n<!-- In the Xamarin.Forms -->\n<Entry Text=\"{Binding Name.Value}\" />\n\n\n\n\n\n\nWe forget the \n.Value\n sometimes. If you have a ReSharper license, then you can use this plugin.\n\nReactiveProperty XAML Binding Corrector\n\nHighlight the missing of ReactiveProperty \".Value\" in XAML.\n\n\n\n\nHow to create a ReactiveProperty instance\n\n\nThe ReactiveProperty class can create from many methods.\n\n\nCreate from the constructor\n\n\nThe most simplest way is that using the constructor.\n\n\n// create with the default value.\nvar name = new ReactiveProperty<string>();\nConsole.WriteLine(name.Value); // -> empty output\n\n// create with the initial value.\nvar name = new ReactiveProperty<string>(\"okazuki\");\nConsole.WriteLine(name.Value); // -> okazuki\n\n\n\n\nCreate from the IObservable<T>\n\n\nThis can create from the IObservable<T>.\nJust calls the \nToReactiveProperty\n method.\n\n\nIObservable<long> observableInstance = Observable.Interval(TimeSpan.FromSeconds(1));\n\n// Convert to ReactiveProperty from IObservable.\nReactiveProperty<long> counter = observableInstance.ToReactiveProperty();\n\n\n\n\nCreate from the ReactiveProperty\n\n\nThe ReactiveProperty implements the IObservable interface.\nIt means that a ReactiveProperty can be created from ReactiveProperty.\n\n\nvar name = new ReactiveProperty<string>(\"\");\n\nvar formalName = name.Select(x => $\"Dear {x}\")\n    .ToReactiveProperty();\n\n\n\n\nAll IObservable instances can become a ReactiveProperty. \n\n\nValidation\n\n\nThe ReactiveProperty class implements the INotifyDataErrorInfo interface.\n\n\nSet custom validation logics\n\n\nYou can set the custom validation logic using the SetValidateNotifyError method.\n\n\nvar name = new ReactiveProperty<string>()\n    .SetValidateNotifyError(x => string.IsNullOrWhiteSpace(x) ? \"Error message\" : null);\n\n\n\n\nIn the valid value case, the validation logic should return null.\nIn the invalid value case, the logic should return a error message.\n\n\nWork with DataAnnotations\n\n\nThis class can work together with the DataAnnotations.\nYou can set the validation attribute using the SetValidateAttribute method.\n\n\nclass ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            // Set validation attributes into the ReactiveProperty.\n            .SetValidateAttribute(() => Name);\n    }\n}\n\n\n\n\nWPF is integrated the INotifyDataErrorInfo interface. See below.\n\n\n\n\nHandling validation errors\n\n\nOther platform can't display the error message from the INofityDataErrorInfo interface.\nThe ReactiveProperty class have some properties for handling validation errors.\n\n\nA first property is \nObserveErrorChanged\n.\nThis type is \nIObservable<IEnumerable>\n. You can convert to an error message from IEnumerable. See below.\n\n\nclass ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ReactiveProperty<string> NameErrorMessage { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            // Set validation attributes into the ReactiveProperty.\n            .SetValidateAttribute(() => Name);\n\n        // Handling an error message\n        NameErrorMessage = Name.ObserveErrorChanged\n            .Select(x => x?.OfType<string>()?.FirstOrDefault())\n            .ToReactiveProperty();\n    }\n}\n\n\n\n\nBind \nNameErrorMessage.Value\n property to a text control. An error message can be displayed.\n\n\nIn the case of UWP, see below.\n\n\npublic sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.NameErrorMessage.Value, Mode=OneWay}\"\n                   Foreground=\"Red\"\n                   Margin=\"5,0\"\n                   Style=\"{ThemeResource BodyTextBlockStyle}\" />\n    </StackPanel>\n</Page>\n\n\n\n\n\n\nA next property is \nObserveHasErrors\n. The \nObserveHasErrors\n property type is \nIObservable<bool>\n.\nIn popular input form case, combine \nObserveHasErrors\n property values very useful.\n\n\nThis sample program is that create a HasErros property that type is ReactiveProperty<bool> that combine two ReactiveProperty's ObserveHasErrors properties.\n\n\npublic class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    [Required(ErrorMessage = \"The memo is required.\")]\n    public ReactiveProperty<string> Memo { get; }\n\n    public ReactiveProperty<bool> HasErrors { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n\n        Memo = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Memo);\n\n        // You can combine some ObserveHasErrors values.\n        HasErrors = new[]\n            {\n                Name.ObserveHasErrors,\n                Memo.ObserveHasErrors,\n            }.CombineLatest(x => x.Any(y => y))\n            .ToReactiveProperty();\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\" \n                   Margin=\"5\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"Memo\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5\" />\n        <TextBox Text=\"{x:Bind ViewModel.Memo.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"HasErrors\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5\" />\n        <CheckBox IsChecked=\"{x:Bind ViewModel.HasErrors.Value, Mode=OneWay}\"\n                  IsEnabled=\"False\"\n                  Margin=\"5\" />\n    </StackPanel>\n</Page>\n\n\n\n\n\n\n\n\nThe last property is \nHasErrors\n. It is a just bool property.\n\n\npublic class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n    }\n\n    public void DoSomething()\n    {\n        if (Name.HasErrors)\n        {\n            // invalid value case\n        }\n        else\n        {\n            // valid value case\n        }\n    }\n}\n\n\n\n\nDon't need initial validation error\n\n\nIn the default behavior, the ReactiveProperty report errors when the validation logic set.\nIf you don't need the initial validation error, then you can skip the error.\nJust call the Skip method.\n\n\nclass ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ReactiveProperty<string> NameErrorMessage { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n\n        // Handling an error message\n        NameErrorMessage = Name.ObserveErrorChanged\n            .Skip(1) // Skip the first error.\n            .Select(x => x?.OfType<string>()?.FirstOrDefault())\n            .ToReactiveProperty();\n    }\n}\n\n\n\n\nThe mode of ReactiveProperty\n\n\nThe ReactiveProperty class call a OnNext callback when the Subscribe method called.\n\n\nvar x = new ReactiveProperty<string>(\"initial value\");\nx.Subscribe(x => Console.WriteLine(x)); // -> initial value\n\n\n\n\nYou could change this behavior when the ReactiveProperty instance create.\nThe constructor and the ToReactiveProperty method have a mode argument.\nThis can be set following values.\n\n\n\n\nReactivePropertyMode.None\n\n\nReactiveProperty doesn't call an OnNext callback when the Subscribe method call. And call an OnNext callback if the same value set.\n\n\n\n\n\n\nReactivePropertyMode.DistinctUntilChanged\n\n\nThis doesn't call an OnNext callback if the same value set.\n\n\n\n\n\n\nReactivePropertyMode.RaiseLatestValueOnSubscribe\n\n\nThis calls an OnNext callback when the Subscribe method call.\n\n\n\n\n\n\n\n\nThe default value is \nReactivePropertyMode.DistinctUntilChanged | ReactivePropertyMode.RaiseLatestValueOnSubscribe\n.\n\n\nIf you don't need this behavior then you can set the ReactivePropertyMode.None value.\n\n\nvar x = new ReactiveProperty<string>(\"initial value\", mode: ReactivePropertyMode.None);\nx.Subscribe(x => Console.WriteLine(x)); // -> don't output the value\nx.Value = \"initial value\"; // -> initial value\n\n\n\n\nReadOnlyReactiveProperty class\n\n\nIf you never set the Value property, then you can use the ReadOnlyReactiveProperty class.\nThis class can't set the property, and other behavior is same the ReactiveProperty class.\nThe ReadOnlyReactiveProperty class is created from ToReadOnlyReactiveProperty extension method.\n\n\nSee below.\n\n\npublic class ViewModel\n{\n    public ReactiveProperty<string> Input { get; }\n\n    // Output never set value.\n    public ReadOnlyReactiveProperty<string> Output { get; }\n\n    public ViewModel()\n    {\n        Input = new ReactiveProperty<string>(\"\");\n        Output = Input\n            .Delay(TimeSpan.FromSeconds(1))\n            .Select(x => x.ToUpper())\n            .ToReadOnlyReactiveProperty(); // convert to ReadOnlyReactiveProperty\n    }\n}\n\n\n\n\nUnsubscribe\n\n\nThe ReactiveProperty class implements the IDisposable interface.\nWhen the Dispose method called, the ReactiveProperty class release all subscription.\nIn other instance's events subscribe, then you should call the Dispose method when the end of ViewModel lifecycle.\n\n\npublic class ViewModel : IDisposable\n{\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveProperty();\n    }\n\n    public void Dispose()\n    {\n        // Unsbscribe\n        Time.Dispose();\n    }\n}",
            "title": "ReactiveProperty class"
        },
        {
            "location": "/features/ReactivePropertyClass/#reactiveproperty-class",
            "text": "ReactiveProperty is core class of this library.\nThis has following features.   Implements the INotifyPropretyChanged interface.  The value property raise the PropertyChanged event.    Implements the IObservable<T> interface.   Yes, The value property can bind to XAML control's property.\nAnd the class call the IObserver<T>#OnNext method when set the value.  A sample code is below.  using Reactive.Bindings;\nusing System;\n\nnamespace ReactivePropertyEduApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // create from defualt constructor(default value is null)\n            var name = new ReactiveProperty<string>();\n            // setup the event handler and the onNext callback.\n            name.PropertyChanged += (_, e) => Console.WriteLine($\"PropertyChanged: {e.PropertyName}\");\n            name.Subscribe(x => Console.WriteLine($\"OnNext: {x}\"));\n\n            // update the value property.\n            name.Value = \"neuecc\";\n            name.Value = \"xin9le\";\n            name.Value = \"okazuki\";\n        }\n    }\n}  The output of this program is below.  OnNext:\nOnNext: neuecc\nPropertyChanged: Value\nOnNext: xin9le\nPropertyChanged: Value\nOnNext: okazuki\nPropertyChanged: Value  What's deferent between PropertyChanged and onNext callback?\nThe onNext is called when subscribe. The PropertyChanged isn't called when added the event handler. And the onNext callback's argument is the property value, the PropertyChanged argument don't have the property value.  The PropertyChanged event was provided for the data binding. In the normal case, you should use the Reactive Extensions methods.",
            "title": "ReactiveProperty class"
        },
        {
            "location": "/features/ReactivePropertyClass/#use-with-the-xaml-platform",
            "text": "The ReactiveProperty class is designed for the XAML platform which is like WPF, UWP, and Xamarin.Forms.\nThis class can be used the ViewModel layer.   In the case that don't use the ReactiveProperty, the ViewModel class wrote the below.   public class MainPageViewModel : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string _name;\n    public string Name\n    {\n        get => _name;\n        set\n        {\n            _name = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n        }\n    }\n\n    // Other properties are defined similar codes.\n}  And those properties binds in the XAML code.  <!-- In the WPF -->\n<TextBox Text=\"{Binding Name}\" />\n\n<!-- In the UWP(Runtime data binding) -->\n<TextBox Text=\"{Binding Name}\" />\n\n<!-- In the UWP(Compile time data binding) -->\n<TextBox Text=\"{x:Bind ViewModel.Name, Mode=TwoWay}\" />\n\n<!-- In the Xamarin.Forms -->\n<Entry Text=\"{Binding Name}\" />  In the case that uses the ReactiveProperty, The ViewModel code becomes very simple!  // The INotifyPropertyChanged interface must implement when using the WPF.\n// Because, if you don't implement this, then memory leak occurred.\npublic class MainPageViewModel\n{\n    public ReactiveProperty<string> Name { get; } = new ReactiveProperty<string>();\n\n    // Other properties are defined similar codes.\n}  When binding in the XAML code, you must add the  .Value  in the binding path.\nThis is an only limitation of this library.  <!-- In the WPF -->\n<TextBox Text=\"{Binding Name.Value}\" />\n\n<!-- In the UWP(Runtime data binding) -->\n<TextBox Text=\"{Binding Name}.Value\" />\n\n<!-- In the UWP(Compile time data binding) -->\n<TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay}\" />\n\n<!-- In the Xamarin.Forms -->\n<Entry Text=\"{Binding Name.Value}\" />   We forget the  .Value  sometimes. If you have a ReSharper license, then you can use this plugin. ReactiveProperty XAML Binding Corrector \nHighlight the missing of ReactiveProperty \".Value\" in XAML.",
            "title": "Use with the XAML platform"
        },
        {
            "location": "/features/ReactivePropertyClass/#how-to-create-a-reactiveproperty-instance",
            "text": "The ReactiveProperty class can create from many methods.",
            "title": "How to create a ReactiveProperty instance"
        },
        {
            "location": "/features/ReactivePropertyClass/#create-from-the-constructor",
            "text": "The most simplest way is that using the constructor.  // create with the default value.\nvar name = new ReactiveProperty<string>();\nConsole.WriteLine(name.Value); // -> empty output\n\n// create with the initial value.\nvar name = new ReactiveProperty<string>(\"okazuki\");\nConsole.WriteLine(name.Value); // -> okazuki",
            "title": "Create from the constructor"
        },
        {
            "location": "/features/ReactivePropertyClass/#create-from-the-iobservablet",
            "text": "This can create from the IObservable<T>.\nJust calls the  ToReactiveProperty  method.  IObservable<long> observableInstance = Observable.Interval(TimeSpan.FromSeconds(1));\n\n// Convert to ReactiveProperty from IObservable.\nReactiveProperty<long> counter = observableInstance.ToReactiveProperty();",
            "title": "Create from the IObservable&lt;T&gt;"
        },
        {
            "location": "/features/ReactivePropertyClass/#create-from-the-reactiveproperty",
            "text": "The ReactiveProperty implements the IObservable interface.\nIt means that a ReactiveProperty can be created from ReactiveProperty.  var name = new ReactiveProperty<string>(\"\");\n\nvar formalName = name.Select(x => $\"Dear {x}\")\n    .ToReactiveProperty();  All IObservable instances can become a ReactiveProperty.",
            "title": "Create from the ReactiveProperty"
        },
        {
            "location": "/features/ReactivePropertyClass/#validation",
            "text": "The ReactiveProperty class implements the INotifyDataErrorInfo interface.",
            "title": "Validation"
        },
        {
            "location": "/features/ReactivePropertyClass/#set-custom-validation-logics",
            "text": "You can set the custom validation logic using the SetValidateNotifyError method.  var name = new ReactiveProperty<string>()\n    .SetValidateNotifyError(x => string.IsNullOrWhiteSpace(x) ? \"Error message\" : null);  In the valid value case, the validation logic should return null.\nIn the invalid value case, the logic should return a error message.",
            "title": "Set custom validation logics"
        },
        {
            "location": "/features/ReactivePropertyClass/#work-with-dataannotations",
            "text": "This class can work together with the DataAnnotations.\nYou can set the validation attribute using the SetValidateAttribute method.  class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            // Set validation attributes into the ReactiveProperty.\n            .SetValidateAttribute(() => Name);\n    }\n}  WPF is integrated the INotifyDataErrorInfo interface. See below.",
            "title": "Work with DataAnnotations"
        },
        {
            "location": "/features/ReactivePropertyClass/#handling-validation-errors",
            "text": "Other platform can't display the error message from the INofityDataErrorInfo interface.\nThe ReactiveProperty class have some properties for handling validation errors.  A first property is  ObserveErrorChanged .\nThis type is  IObservable<IEnumerable> . You can convert to an error message from IEnumerable. See below.  class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ReactiveProperty<string> NameErrorMessage { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            // Set validation attributes into the ReactiveProperty.\n            .SetValidateAttribute(() => Name);\n\n        // Handling an error message\n        NameErrorMessage = Name.ObserveErrorChanged\n            .Select(x => x?.OfType<string>()?.FirstOrDefault())\n            .ToReactiveProperty();\n    }\n}  Bind  NameErrorMessage.Value  property to a text control. An error message can be displayed.  In the case of UWP, see below.  public sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.NameErrorMessage.Value, Mode=OneWay}\"\n                   Foreground=\"Red\"\n                   Margin=\"5,0\"\n                   Style=\"{ThemeResource BodyTextBlockStyle}\" />\n    </StackPanel>\n</Page>   A next property is  ObserveHasErrors . The  ObserveHasErrors  property type is  IObservable<bool> .\nIn popular input form case, combine  ObserveHasErrors  property values very useful.  This sample program is that create a HasErros property that type is ReactiveProperty<bool> that combine two ReactiveProperty's ObserveHasErrors properties.  public class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    [Required(ErrorMessage = \"The memo is required.\")]\n    public ReactiveProperty<string> Memo { get; }\n\n    public ReactiveProperty<bool> HasErrors { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n\n        Memo = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Memo);\n\n        // You can combine some ObserveHasErrors values.\n        HasErrors = new[]\n            {\n                Name.ObserveHasErrors,\n                Memo.ObserveHasErrors,\n            }.CombineLatest(x => x.Any(y => y))\n            .ToReactiveProperty();\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\" \n                   Margin=\"5\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"Memo\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5\" />\n        <TextBox Text=\"{x:Bind ViewModel.Memo.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"HasErrors\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5\" />\n        <CheckBox IsChecked=\"{x:Bind ViewModel.HasErrors.Value, Mode=OneWay}\"\n                  IsEnabled=\"False\"\n                  Margin=\"5\" />\n    </StackPanel>\n</Page>    The last property is  HasErrors . It is a just bool property.  public class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n    }\n\n    public void DoSomething()\n    {\n        if (Name.HasErrors)\n        {\n            // invalid value case\n        }\n        else\n        {\n            // valid value case\n        }\n    }\n}",
            "title": "Handling validation errors"
        },
        {
            "location": "/features/ReactivePropertyClass/#dont-need-initial-validation-error",
            "text": "In the default behavior, the ReactiveProperty report errors when the validation logic set.\nIf you don't need the initial validation error, then you can skip the error.\nJust call the Skip method.  class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ReactiveProperty<string> NameErrorMessage { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n\n        // Handling an error message\n        NameErrorMessage = Name.ObserveErrorChanged\n            .Skip(1) // Skip the first error.\n            .Select(x => x?.OfType<string>()?.FirstOrDefault())\n            .ToReactiveProperty();\n    }\n}",
            "title": "Don't need initial validation error"
        },
        {
            "location": "/features/ReactivePropertyClass/#the-mode-of-reactiveproperty",
            "text": "The ReactiveProperty class call a OnNext callback when the Subscribe method called.  var x = new ReactiveProperty<string>(\"initial value\");\nx.Subscribe(x => Console.WriteLine(x)); // -> initial value  You could change this behavior when the ReactiveProperty instance create.\nThe constructor and the ToReactiveProperty method have a mode argument.\nThis can be set following values.   ReactivePropertyMode.None  ReactiveProperty doesn't call an OnNext callback when the Subscribe method call. And call an OnNext callback if the same value set.    ReactivePropertyMode.DistinctUntilChanged  This doesn't call an OnNext callback if the same value set.    ReactivePropertyMode.RaiseLatestValueOnSubscribe  This calls an OnNext callback when the Subscribe method call.     The default value is  ReactivePropertyMode.DistinctUntilChanged | ReactivePropertyMode.RaiseLatestValueOnSubscribe .  If you don't need this behavior then you can set the ReactivePropertyMode.None value.  var x = new ReactiveProperty<string>(\"initial value\", mode: ReactivePropertyMode.None);\nx.Subscribe(x => Console.WriteLine(x)); // -> don't output the value\nx.Value = \"initial value\"; // -> initial value",
            "title": "The mode of ReactiveProperty"
        },
        {
            "location": "/features/ReactivePropertyClass/#readonlyreactiveproperty-class",
            "text": "If you never set the Value property, then you can use the ReadOnlyReactiveProperty class.\nThis class can't set the property, and other behavior is same the ReactiveProperty class.\nThe ReadOnlyReactiveProperty class is created from ToReadOnlyReactiveProperty extension method.  See below.  public class ViewModel\n{\n    public ReactiveProperty<string> Input { get; }\n\n    // Output never set value.\n    public ReadOnlyReactiveProperty<string> Output { get; }\n\n    public ViewModel()\n    {\n        Input = new ReactiveProperty<string>(\"\");\n        Output = Input\n            .Delay(TimeSpan.FromSeconds(1))\n            .Select(x => x.ToUpper())\n            .ToReadOnlyReactiveProperty(); // convert to ReadOnlyReactiveProperty\n    }\n}",
            "title": "ReadOnlyReactiveProperty class"
        },
        {
            "location": "/features/ReactivePropertyClass/#unsubscribe",
            "text": "The ReactiveProperty class implements the IDisposable interface.\nWhen the Dispose method called, the ReactiveProperty class release all subscription.\nIn other instance's events subscribe, then you should call the Dispose method when the end of ViewModel lifecycle.  public class ViewModel : IDisposable\n{\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveProperty();\n    }\n\n    public void Dispose()\n    {\n        // Unsbscribe\n        Time.Dispose();\n    }\n}",
            "title": "Unsubscribe"
        },
        {
            "location": "/getting-started/uwp/",
            "text": "UWP\n\n\nCreate a project\n\n\n\n\n\n\nCreate a Blank App (Universal Windows) project.\n\n\n\n\nSet a \nTarget version\n item to Windows 10 Fall Creators Update (1.0.: Build 16299) and \nMinimum version\n item to the same.\n\n\n\n\n\n\nThe ReactiveProperty target the .NET Standard 1.3. You can use this library with the another version UWP. My recomended version is after the Createors Update. After this version can use compile time binding.\n\n\n\n\n\n\nInstall the ReactiveProperty package from NuGet.\n\n\n\n\n\n\nEdit codes\n\n\n\n\nCreate a MainPageViewModel.cs file.\n\n\nEdit files like following.\n\n\n\n\nMainPageViewModel.cs\n\n\nusing Reactive.Bindings;\nusing System;\nusing System.Linq;\nusing System.Reactive.Linq;\n\nnamespace GettingStartedUWP\n{\n    public class MainPageViewModel\n    {\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainPageViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}\n\n\n\n\nMainPage.xaml.cs\n\n\nusing Windows.UI.Xaml.Controls;\n\n// The Blank Page item template is documented at https://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409\n\nnamespace GettingStartedUWP\n{\n    /// <summary>\n    /// An empty page that can be used on its own or navigated to within a Frame.\n    /// </summary>\n    public sealed partial class MainPage : Page\n    {\n        private MainPageViewModel ViewModel { get; } = new MainPageViewModel();\n        public MainPage()\n        {\n            this.InitializeComponent();\n        }\n    }\n}\n\n\n\n\nMainPage.xaml\n\n\n<Page x:Class=\"GettingStartedUWP.MainPage\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:GettingStartedUWP\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\">\n\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Input\"\n                Style=\"{StaticResource CaptionTextBlockStyle}\" />\n        <TextBox Text=\"{x:Bind ViewModel.Input.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"Output\"\n                Style=\"{StaticResource CaptionTextBlockStyle}\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Output.Value, Mode=OneWay}\"\n                Style=\"{StaticResource BodyTextBlockStyle}\"\n                Margin=\"5\" />\n    </StackPanel>\n</Page>\n\n\n\n\nLaunch the application\n\n\nAfter launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "UWP"
        },
        {
            "location": "/getting-started/uwp/#uwp",
            "text": "",
            "title": "UWP"
        },
        {
            "location": "/getting-started/uwp/#create-a-project",
            "text": "Create a Blank App (Universal Windows) project.   Set a  Target version  item to Windows 10 Fall Creators Update (1.0.: Build 16299) and  Minimum version  item to the same.    The ReactiveProperty target the .NET Standard 1.3. You can use this library with the another version UWP. My recomended version is after the Createors Update. After this version can use compile time binding.    Install the ReactiveProperty package from NuGet.",
            "title": "Create a project"
        },
        {
            "location": "/getting-started/uwp/#edit-codes",
            "text": "Create a MainPageViewModel.cs file.  Edit files like following.   MainPageViewModel.cs  using Reactive.Bindings;\nusing System;\nusing System.Linq;\nusing System.Reactive.Linq;\n\nnamespace GettingStartedUWP\n{\n    public class MainPageViewModel\n    {\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainPageViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}  MainPage.xaml.cs  using Windows.UI.Xaml.Controls;\n\n// The Blank Page item template is documented at https://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409\n\nnamespace GettingStartedUWP\n{\n    /// <summary>\n    /// An empty page that can be used on its own or navigated to within a Frame.\n    /// </summary>\n    public sealed partial class MainPage : Page\n    {\n        private MainPageViewModel ViewModel { get; } = new MainPageViewModel();\n        public MainPage()\n        {\n            this.InitializeComponent();\n        }\n    }\n}  MainPage.xaml  <Page x:Class=\"GettingStartedUWP.MainPage\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:GettingStartedUWP\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\">\n\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Input\"\n                Style=\"{StaticResource CaptionTextBlockStyle}\" />\n        <TextBox Text=\"{x:Bind ViewModel.Input.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"Output\"\n                Style=\"{StaticResource CaptionTextBlockStyle}\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Output.Value, Mode=OneWay}\"\n                Style=\"{StaticResource BodyTextBlockStyle}\"\n                Margin=\"5\" />\n    </StackPanel>\n</Page>",
            "title": "Edit codes"
        },
        {
            "location": "/getting-started/uwp/#launch-the-application",
            "text": "After launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Launch the application"
        },
        {
            "location": "/getting-started/wpf/",
            "text": "WPF\n\n\nCreate a project\n\n\n\n\nCreate a WPF App (.NET Framework) project.\n\n\nInstall the ReactiveProperty from NuGet.\n\n\n\n\nEdit codes\n\n\n\n\nCreate a MainWindowViewModel.cs file.\n\n\nEdit files like following.\n\n\n\n\nMainWindowViewModel.cs\n\n\nusing Reactive.Bindings;\nusing System;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Reactive.Linq;\n\nnamespace WpfApp1\n{\n    class MainWindowViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainWindowViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}\n\n\n\n\nMainWindow.xaml\n\n\n<Window x:Class=\"WpfApp1.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WpfApp1\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\"\n        Height=\"350\"\n        Width=\"525\">\n    <Window.DataContext>\n        <local:MainWindowViewModel />\n    </Window.DataContext>\n    <StackPanel>\n        <Label Content=\"Input\" />\n        <TextBox Text=\"{Binding Input.Value, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <Label Content=\"Output\" />\n        <TextBlock Text=\"{Binding Output.Value}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Window>\n\n\n\n\nLaunch the application.\n\n\nAfter launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "WPF"
        },
        {
            "location": "/getting-started/wpf/#wpf",
            "text": "",
            "title": "WPF"
        },
        {
            "location": "/getting-started/wpf/#create-a-project",
            "text": "Create a WPF App (.NET Framework) project.  Install the ReactiveProperty from NuGet.",
            "title": "Create a project"
        },
        {
            "location": "/getting-started/wpf/#edit-codes",
            "text": "Create a MainWindowViewModel.cs file.  Edit files like following.   MainWindowViewModel.cs  using Reactive.Bindings;\nusing System;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Reactive.Linq;\n\nnamespace WpfApp1\n{\n    class MainWindowViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainWindowViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}  MainWindow.xaml  <Window x:Class=\"WpfApp1.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WpfApp1\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\"\n        Height=\"350\"\n        Width=\"525\">\n    <Window.DataContext>\n        <local:MainWindowViewModel />\n    </Window.DataContext>\n    <StackPanel>\n        <Label Content=\"Input\" />\n        <TextBox Text=\"{Binding Input.Value, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <Label Content=\"Output\" />\n        <TextBlock Text=\"{Binding Output.Value}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Window>",
            "title": "Edit codes"
        },
        {
            "location": "/getting-started/wpf/#launch-the-application",
            "text": "After launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Launch the application."
        },
        {
            "location": "/getting-started/xamarin-forms/",
            "text": "Xamarin.Forms\n\n\nCreate a project\n\n\n\n\nCreate a Cross Platform app (Xamarin.Forms) project.\n\n\nSetting the \nNew Cross Platform App\n dialog like following.\n  Choice the .NET Standard project. Of couse you can select shared project.\n  \n\n\nInstall the ReactiveProperty to all projects from NGet.\n\n\n\n\nEdit codes\n\n\nTBD",
            "title": "Xamarin.Forms"
        },
        {
            "location": "/getting-started/xamarin-forms/#xamarinforms",
            "text": "",
            "title": "Xamarin.Forms"
        },
        {
            "location": "/getting-started/xamarin-forms/#create-a-project",
            "text": "Create a Cross Platform app (Xamarin.Forms) project.  Setting the  New Cross Platform App  dialog like following.\n  Choice the .NET Standard project. Of couse you can select shared project.\n    Install the ReactiveProperty to all projects from NGet.",
            "title": "Create a project"
        },
        {
            "location": "/getting-started/xamarin-forms/#edit-codes",
            "text": "TBD",
            "title": "Edit codes"
        }
    ]
}