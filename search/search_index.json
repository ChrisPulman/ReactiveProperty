{
    "docs": [
        {
            "location": "/",
            "text": "What is ReactiveProperty\n\n\nReactiveProperty provides MVVM and asynchronous support features under Reactive Extensions. Target framework is .NET 4.6, UWP, Xamarin.iOS, Xamarin.Android, Xamarin.Mac, Xamarin.Forms and .NET Standard 1.3.\n\n\n\n\nConcept of ReactiveProperty is \nFun programing\n.\nYou can write MVVM pattern program using ReactiveProperty very fun.\n\n\n\n\nFollowing code is tow way binding between ReactiveProperty and plane object property.\n\n\nclass Model : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string _name;\n    public string Name\n    {\n        get => _name;\n        set\n        {\n            _name = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n        }\n    }\n}\nclass ViewModel\n{\n    private readonly Model _model = new Model();\n    public ReactiveProperty<string> Name { get; }\n    public ViewModel()\n    {\n        // TwoWay synchronize to ReactiveProperty and Model#Name property.\n        Name = _model.ToReactivePropertyAsSynchronized(x => x.Name);\n    }\n}\n\n\n\n\nReactiveProperty is implemented the IObservable<T>. Yes! You can use LINQ.\n\n\nvar name = new ReactiveProperty<string>();\nname.Where(x => x.StartsWith(\"_\")) // filter\n    .Select(x => x.ToUpper()) // convert\n    .Subscribe(x => { ... some action ... });\n\n\n\n\nReactiveProperty is created from IObservable<T>. \n\n\nclass ViewModel\n{\n    public ReactiveProperty<string> Input { get; }\n    public ReactiveProperty<string> Output { get; }\n\n    public ViewModel()\n    {\n        Input = new ReactiveProperty(\"\");\n        Output = Input\n            .Delay(TimeSpan.FromSecond(1)) // Using a Rx method.\n            .Select(x => x.ToUpper()) // Using a LINQ method.\n            .ToReactiveProperty(); // Convert to ReactiveProperty\n    }\n}\n\n\n\n\nThis method chain is very cool.\n\n\nAnd we provide ReactiveCommand class what implements ICommand and IObservable<T> interfaces. ReactiveCommand can create from an IObservable<bool>\n\n\nvar command = Observable.Interval(TimeSpan.FromSecond(1))\n    .Select(x => x % 2 == 0) // convert to IO<bool>\n    .ToReactiveCommand();\ncommand.Subscribe(_ =>\n{\n    // ReactiveCommand invoke an OnNext when Execute method was called.\n});\n\n\n\n\nYou can start the ReactiveProperty from following links.\n\n\n\n\nWindows Presentation Foundation\n\n\nUniversal Windows Platform\n\n\nXamarin.Forms\n\n\n\n\nAnd learn to core features on following links.\n\n\n\n\nReactiveProperty\n\n\nCommanding\n\n\nCollections",
            "title": "Home"
        },
        {
            "location": "/#what-is-reactiveproperty",
            "text": "ReactiveProperty provides MVVM and asynchronous support features under Reactive Extensions. Target framework is .NET 4.6, UWP, Xamarin.iOS, Xamarin.Android, Xamarin.Mac, Xamarin.Forms and .NET Standard 1.3.   Concept of ReactiveProperty is  Fun programing .\nYou can write MVVM pattern program using ReactiveProperty very fun.   Following code is tow way binding between ReactiveProperty and plane object property.  class Model : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string _name;\n    public string Name\n    {\n        get => _name;\n        set\n        {\n            _name = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n        }\n    }\n}\nclass ViewModel\n{\n    private readonly Model _model = new Model();\n    public ReactiveProperty<string> Name { get; }\n    public ViewModel()\n    {\n        // TwoWay synchronize to ReactiveProperty and Model#Name property.\n        Name = _model.ToReactivePropertyAsSynchronized(x => x.Name);\n    }\n}  ReactiveProperty is implemented the IObservable<T>. Yes! You can use LINQ.  var name = new ReactiveProperty<string>();\nname.Where(x => x.StartsWith(\"_\")) // filter\n    .Select(x => x.ToUpper()) // convert\n    .Subscribe(x => { ... some action ... });  ReactiveProperty is created from IObservable<T>.   class ViewModel\n{\n    public ReactiveProperty<string> Input { get; }\n    public ReactiveProperty<string> Output { get; }\n\n    public ViewModel()\n    {\n        Input = new ReactiveProperty(\"\");\n        Output = Input\n            .Delay(TimeSpan.FromSecond(1)) // Using a Rx method.\n            .Select(x => x.ToUpper()) // Using a LINQ method.\n            .ToReactiveProperty(); // Convert to ReactiveProperty\n    }\n}  This method chain is very cool.  And we provide ReactiveCommand class what implements ICommand and IObservable<T> interfaces. ReactiveCommand can create from an IObservable<bool>  var command = Observable.Interval(TimeSpan.FromSecond(1))\n    .Select(x => x % 2 == 0) // convert to IO<bool>\n    .ToReactiveCommand();\ncommand.Subscribe(_ =>\n{\n    // ReactiveCommand invoke an OnNext when Execute method was called.\n});  You can start the ReactiveProperty from following links.   Windows Presentation Foundation  Universal Windows Platform  Xamarin.Forms   And learn to core features on following links.   ReactiveProperty  Commanding  Collections",
            "title": "What is ReactiveProperty"
        },
        {
            "location": "/getting-started/wpf/",
            "text": "Create a project\n\n\n\n\nCreate a WPF App (.NET Framework) project.\n\n\nInstall ReactiveProperty from NuGet.\n\n\n\n\nEdit codes\n\n\n\n\nCreate a MainWindowViewModel.cs file.\n\n\nEdit files like following.\n\n\n\n\nMainWindowViewModel.cs\n\n\nusing Reactive.Bindings;\nusing System;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Reactive.Linq;\n\nnamespace WpfApp1\n{\n    class MainWindowViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainWindowViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}\n\n\n\n\nMainWindow.xaml\n\n\n<Window x:Class=\"WpfApp1.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WpfApp1\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\"\n        Height=\"350\"\n        Width=\"525\">\n    <Window.DataContext>\n        <local:MainWindowViewModel />\n    </Window.DataContext>\n    <StackPanel>\n        <Label Content=\"Input\" />\n        <TextBox Text=\"{Binding Input.Value, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <Label Content=\"Output\" />\n        <TextBlock Text=\"{Binding Output.Value}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Window>\n\n\n\n\nLaunch the application.\n\n\nAfter launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Windows Presentation Foundation"
        },
        {
            "location": "/getting-started/wpf/#create-a-project",
            "text": "Create a WPF App (.NET Framework) project.  Install ReactiveProperty from NuGet.",
            "title": "Create a project"
        },
        {
            "location": "/getting-started/wpf/#edit-codes",
            "text": "Create a MainWindowViewModel.cs file.  Edit files like following.   MainWindowViewModel.cs  using Reactive.Bindings;\nusing System;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Reactive.Linq;\n\nnamespace WpfApp1\n{\n    class MainWindowViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainWindowViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}  MainWindow.xaml  <Window x:Class=\"WpfApp1.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WpfApp1\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\"\n        Height=\"350\"\n        Width=\"525\">\n    <Window.DataContext>\n        <local:MainWindowViewModel />\n    </Window.DataContext>\n    <StackPanel>\n        <Label Content=\"Input\" />\n        <TextBox Text=\"{Binding Input.Value, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <Label Content=\"Output\" />\n        <TextBlock Text=\"{Binding Output.Value}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Window>",
            "title": "Edit codes"
        },
        {
            "location": "/getting-started/wpf/#launch-the-application",
            "text": "After launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Launch the application."
        },
        {
            "location": "/getting-started/uwp/",
            "text": "Create a project\n\n\n\n\n\n\nCreate a Blank App (Universal Windows) project.\n\n\n\n\nSet a \nTarget version\n item to Windows 10 Fall Creators Update (1.0.: Build 16299) and \nMinimum version\n item to the same.\n\n\n\n\n\n\nReactiveProperty target the .NET Standard 1.3. You can use this library with the another version UWP. My recomended version is after the Createors Update. After this version can use compile time binding.\n\n\n\n\n\n\nInstall ReactiveProperty package from NuGet.\n\n\n\n\n\n\nEdit codes\n\n\n\n\nCreate a MainPageViewModel.cs file.\n\n\nEdit files like following.\n\n\n\n\nMainPageViewModel.cs\n\n\nusing Reactive.Bindings;\nusing System;\nusing System.Linq;\nusing System.Reactive.Linq;\n\nnamespace GettingStartedUWP\n{\n    public class MainPageViewModel\n    {\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainPageViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}\n\n\n\n\nMainPage.xaml.cs\n\n\nusing Windows.UI.Xaml.Controls;\n\n// The Blank Page item template is documented at https://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409\n\nnamespace GettingStartedUWP\n{\n    /// <summary>\n    /// An empty page that can be used on its own or navigated to within a Frame.\n    /// </summary>\n    public sealed partial class MainPage : Page\n    {\n        private MainPageViewModel ViewModel { get; } = new MainPageViewModel();\n        public MainPage()\n        {\n            this.InitializeComponent();\n        }\n    }\n}\n\n\n\n\nMainPage.xaml\n\n\n<Page x:Class=\"GettingStartedUWP.MainPage\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:GettingStartedUWP\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\">\n\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Input\"\n                Style=\"{StaticResource CaptionTextBlockStyle}\" />\n        <TextBox Text=\"{x:Bind ViewModel.Input.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"Output\"\n                Style=\"{StaticResource CaptionTextBlockStyle}\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Output.Value, Mode=OneWay}\"\n                Style=\"{StaticResource BodyTextBlockStyle}\"\n                Margin=\"5\" />\n    </StackPanel>\n</Page>\n\n\n\n\nLaunch the application\n\n\nAfter launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Universal Windows Platform"
        },
        {
            "location": "/getting-started/uwp/#create-a-project",
            "text": "Create a Blank App (Universal Windows) project.   Set a  Target version  item to Windows 10 Fall Creators Update (1.0.: Build 16299) and  Minimum version  item to the same.    ReactiveProperty target the .NET Standard 1.3. You can use this library with the another version UWP. My recomended version is after the Createors Update. After this version can use compile time binding.    Install ReactiveProperty package from NuGet.",
            "title": "Create a project"
        },
        {
            "location": "/getting-started/uwp/#edit-codes",
            "text": "Create a MainPageViewModel.cs file.  Edit files like following.   MainPageViewModel.cs  using Reactive.Bindings;\nusing System;\nusing System.Linq;\nusing System.Reactive.Linq;\n\nnamespace GettingStartedUWP\n{\n    public class MainPageViewModel\n    {\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainPageViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}  MainPage.xaml.cs  using Windows.UI.Xaml.Controls;\n\n// The Blank Page item template is documented at https://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409\n\nnamespace GettingStartedUWP\n{\n    /// <summary>\n    /// An empty page that can be used on its own or navigated to within a Frame.\n    /// </summary>\n    public sealed partial class MainPage : Page\n    {\n        private MainPageViewModel ViewModel { get; } = new MainPageViewModel();\n        public MainPage()\n        {\n            this.InitializeComponent();\n        }\n    }\n}  MainPage.xaml  <Page x:Class=\"GettingStartedUWP.MainPage\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:GettingStartedUWP\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\">\n\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Input\"\n                Style=\"{StaticResource CaptionTextBlockStyle}\" />\n        <TextBox Text=\"{x:Bind ViewModel.Input.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"Output\"\n                Style=\"{StaticResource CaptionTextBlockStyle}\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Output.Value, Mode=OneWay}\"\n                Style=\"{StaticResource BodyTextBlockStyle}\"\n                Margin=\"5\" />\n    </StackPanel>\n</Page>",
            "title": "Edit codes"
        },
        {
            "location": "/getting-started/uwp/#launch-the-application",
            "text": "After launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Launch the application"
        },
        {
            "location": "/getting-started/xf/",
            "text": "Create a project\n\n\n\n\nCreate a Cross Platform app (Xamarin.Forms) project.\n\n\nSetting the \nNew Cross Platform App\n dialog like following.\n  Choice the .NET Standard project. Of couse you can select shared project.\n  \n\n\nInstall ReactiveProperty to all projects from NuGet.\n\n\n\n\nEdit codes\n\n\n\n\nCreate MainPageViewModel.cs to .NET Standard project.\n\n\nEdit file like following.\n\n\n\n\nMainPageViewModel.cs\n\n\nusing Reactive.Bindings;\nusing System;\nusing System.Reactive.Linq;\n\nnamespace GettingStartedXF\n{\n    public class MainPageViewModel\n    {\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainPageViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}\n\n\n\n\nMainPage.xaml\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             xmlns:local=\"clr-namespace:GettingStartedXF\"\n             x:Class=\"GettingStartedXF.MainPage\">\n    <ContentPage.BindingContext>\n        <local:MainPageViewModel />\n    </ContentPage.BindingContext>\n    <StackLayout>\n        <Entry Text=\"{Binding Input.Value, UpdateSourceEventName=TextChanged}\" />\n        <Label Text=\"{Binding Output.Value}\" />\n    </StackLayout>\n</ContentPage>\n\n\n\n\nLaunch the application.\n\n\nAfter launch the app, you can see below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Xamarin.Forms"
        },
        {
            "location": "/getting-started/xf/#create-a-project",
            "text": "Create a Cross Platform app (Xamarin.Forms) project.  Setting the  New Cross Platform App  dialog like following.\n  Choice the .NET Standard project. Of couse you can select shared project.\n    Install ReactiveProperty to all projects from NuGet.",
            "title": "Create a project"
        },
        {
            "location": "/getting-started/xf/#edit-codes",
            "text": "Create MainPageViewModel.cs to .NET Standard project.  Edit file like following.   MainPageViewModel.cs  using Reactive.Bindings;\nusing System;\nusing System.Reactive.Linq;\n\nnamespace GettingStartedXF\n{\n    public class MainPageViewModel\n    {\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n\n        public MainPageViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}  MainPage.xaml  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             xmlns:local=\"clr-namespace:GettingStartedXF\"\n             x:Class=\"GettingStartedXF.MainPage\">\n    <ContentPage.BindingContext>\n        <local:MainPageViewModel />\n    </ContentPage.BindingContext>\n    <StackLayout>\n        <Entry Text=\"{Binding Input.Value, UpdateSourceEventName=TextChanged}\" />\n        <Label Text=\"{Binding Output.Value}\" />\n    </StackLayout>\n</ContentPage>",
            "title": "Edit codes"
        },
        {
            "location": "/getting-started/xf/#launch-the-application",
            "text": "After launch the app, you can see below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Launch the application."
        },
        {
            "location": "/getting-started/avalonia/",
            "text": "Avalonia is cross platform .NET UI Framework!\n\n\nSee below:\n\n\nAvalonia UI Framework\n\n\nCreate a project\n\n\n\n\nCreate a Avalonia .NET Core Application project.(Of cource! Avalonia Application project can use ReactiveProperty same as .NET Core project.)\n\n\nInstall ReactiveProperty from NuGet.\n\n\n\n\nEdit codes\n\n\n\n\nCreate a MainWindowViewModel.cs file.\n\n\nEdit files like following.\n\n\n\n\nMainWindowViewModel.cs\n\n\nusing Reactive.Bindings;\nusing System;\nusing System.Reactive.Linq;\n\nnamespace AvaloniaApp\n{\n    public class MainWindowViewModel\n    {\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n        public MainWindowViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}\n\n\n\n\nMainWindow.xaml\n\n\n<Window xmlns=\"https://github.com/avaloniaui\" \n        MinWidth=\"200\" \n        MinHeight=\"300\"\n        xmlns:local=\"clr-namespace:AvaloniaApp;assembly=AvaloniaApp\">\n  <Window.DataContext>\n    <local:MainWindowViewModel />\n  </Window.DataContext>\n  <StackPanel>\n    <TextBox Text=\"{Binding Input.Value, Mode=TwoWay}\" />\n    <TextBlock Text=\"{Binding Output.Value}\" />\n  </StackPanel>\n</Window>\n\n\n\n\nLaunch the application.\n\n\nAfter launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Avalonia"
        },
        {
            "location": "/getting-started/avalonia/#create-a-project",
            "text": "Create a Avalonia .NET Core Application project.(Of cource! Avalonia Application project can use ReactiveProperty same as .NET Core project.)  Install ReactiveProperty from NuGet.",
            "title": "Create a project"
        },
        {
            "location": "/getting-started/avalonia/#edit-codes",
            "text": "Create a MainWindowViewModel.cs file.  Edit files like following.   MainWindowViewModel.cs  using Reactive.Bindings;\nusing System;\nusing System.Reactive.Linq;\n\nnamespace AvaloniaApp\n{\n    public class MainWindowViewModel\n    {\n        public ReactiveProperty<string> Input { get; }\n        public ReadOnlyReactiveProperty<string> Output { get; }\n        public MainWindowViewModel()\n        {\n            Input = new ReactiveProperty<string>(\"\");\n            Output = Input\n                .Delay(TimeSpan.FromSeconds(1))\n                .Select(x => x.ToUpper())\n                .ToReadOnlyReactiveProperty();\n        }\n    }\n}  MainWindow.xaml  <Window xmlns=\"https://github.com/avaloniaui\" \n        MinWidth=\"200\" \n        MinHeight=\"300\"\n        xmlns:local=\"clr-namespace:AvaloniaApp;assembly=AvaloniaApp\">\n  <Window.DataContext>\n    <local:MainWindowViewModel />\n  </Window.DataContext>\n  <StackPanel>\n    <TextBox Text=\"{Binding Input.Value, Mode=TwoWay}\" />\n    <TextBlock Text=\"{Binding Output.Value}\" />\n  </StackPanel>\n</Window>",
            "title": "Edit codes"
        },
        {
            "location": "/getting-started/avalonia/#launch-the-application",
            "text": "After launch the app, You can see the below window.\nThe output value was displayed to upper case, after 1sec from the input.",
            "title": "Launch the application."
        },
        {
            "location": "/features/ReactiveProperty/",
            "text": "ReactiveProperty is core class of this library.\nThis has following features.\n\n\n\n\nImplements the INotifyPropretyChanged interface.\n\n\nThe value property raise the PropertyChanged event.\n\n\n\n\n\n\nImplements the IObservable<T> interface.\n\n\n\n\nYes, The value property can bind to XAML control's property.\nAnd the class call the IObserver<T>#OnNext method when set the value.\n\n\nA sample code is as below.\n\n\nusing Reactive.Bindings;\nusing System;\n\nnamespace ReactivePropertyEduApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // create from defualt constructor(default value is null)\n            var name = new ReactiveProperty<string>();\n            // setup the event handler and the onNext callback.\n            name.PropertyChanged += (_, e) => Console.WriteLine($\"PropertyChanged: {e.PropertyName}\");\n            name.Subscribe(x => Console.WriteLine($\"OnNext: {x}\"));\n\n            // update the value property.\n            name.Value = \"neuecc\";\n            name.Value = \"xin9le\";\n            name.Value = \"okazuki\";\n        }\n    }\n}\n\n\n\n\nThe output of this program is below.\n\n\nOnNext:\nOnNext: neuecc\nPropertyChanged: Value\nOnNext: xin9le\nPropertyChanged: Value\nOnNext: okazuki\nPropertyChanged: Value\n\n\n\n\nWhat's deferent between PropertyChanged and onNext callback?\nThe onNext is called when subscribe. The PropertyChanged isn't called when added the event handler. And the onNext callback's argument is the property value, the PropertyChanged argument don't have the property value.\n\n\nThe PropertyChanged event was provided for data binding. In the normal case, you should use Reactive Extensions methods.\n\n\nUse with XAML platform\n\n\nThe ReactiveProperty class is designed for XAML platform which is like WPF, UWP, and Xamarin.Forms.\nThis class can be used a ViewModel layer. \n\n\nIn the case that don't use the ReactiveProperty, a ViewModel class wrote below. \n\n\npublic class MainPageViewModel : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string _name;\n    public string Name\n    {\n        get => _name;\n        set\n        {\n            _name = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n        }\n    }\n\n    // Other properties are defined similar codes.\n}\n\n\n\n\nAnd those properties binds in the XAML code.\n\n\n<!-- In the WPF -->\n<TextBox Text=\"{Binding Name}\" />\n\n<!-- In the UWP(Runtime data binding) -->\n<TextBox Text=\"{Binding Name}\" />\n\n<!-- In the UWP(Compile time data binding) -->\n<TextBox Text=\"{x:Bind ViewModel.Name, Mode=TwoWay}\" />\n\n<!-- In the Xamarin.Forms -->\n<Entry Text=\"{Binding Name}\" />\n\n\n\n\nIn the case that uses the ReactiveProperty, a ViewModel code becomes very simple!\n\n\n// The INotifyPropertyChanged interface must implement when using the WPF.\n// Because, if you don't implement this, then memory leak occurred.\npublic class MainPageViewModel\n{\n    public ReactiveProperty<string> Name { get; } = new ReactiveProperty<string>();\n\n    // Other properties are defined similar codes.\n}\n\n\n\n\nWhen binding in the XAML code, you must add the \n.Value\n in binding path.\nThis is an only limitation of this library.\n\n\n<!-- In the WPF -->\n<TextBox Text=\"{Binding Name.Value}\" />\n\n<!-- In the UWP(Runtime data binding) -->\n<TextBox Text=\"{Binding Name.Value}\" />\n\n<!-- In the UWP(Compile time data binding) -->\n<TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay}\" />\n\n<!-- In the Xamarin.Forms -->\n<Entry Text=\"{Binding Name.Value}\" />\n\n\n\n\n\n\nWe forget the \n.Value\n sometimes. If you have a ReSharper license, then you can use this plugin.\n\nReactiveProperty XAML Binding Corrector\n\nHighlight the missing of ReactiveProperty \".Value\" in XAML.\n\n\n\n\nHow to create a ReactiveProperty instance\n\n\nThe ReactiveProperty class can create from many methods.\n\n\nCreate from the constructor\n\n\nThe simplest way is that using constructor.\n\n\n// create with the default value.\nvar name = new ReactiveProperty<string>();\nConsole.WriteLine(name.Value); // -> empty output\n\n// create with the initial value.\nvar name = new ReactiveProperty<string>(\"okazuki\");\nConsole.WriteLine(name.Value); // -> okazuki\n\n\n\n\nCreate from IObservable<T>\n\n\nThis can create from IObservable<T>.\nJust calls \nToReactiveProperty\n method.\n\n\nIObservable<long> observableInstance = Observable.Interval(TimeSpan.FromSeconds(1));\n\n// Convert to ReactiveProperty from IObservable.\nReactiveProperty<long> counter = observableInstance.ToReactiveProperty();\n\n\n\n\nCreate from ReactiveProperty\n\n\nThe ReactiveProperty implements IObservable interface.\nIt means that ReactiveProperty can be created from ReactiveProperty.\n\n\nvar name = new ReactiveProperty<string>(\"\");\n\nvar formalName = name.Select(x => $\"Dear {x}\")\n    .ToReactiveProperty();\n\n\n\n\nAll IObservable instances can become ReactiveProperty. \n\n\nValidation\n\n\nThe ReactiveProperty class implements INotifyDataErrorInfo interface.\n\n\nSet custom validation logics\n\n\nYou can set custom validation logic using the SetValidateNotifyError method.\n\n\nvar name = new ReactiveProperty<string>()\n    .SetValidateNotifyError(x => string.IsNullOrWhiteSpace(x) ? \"Error message\" : null);\n\n\n\n\nIn the correct value case, validation logic should return null.\nIn invalid value case, logic should return an error message.\n\n\nWork with DataAnnotations\n\n\nThis class can work together with the DataAnnotations.\nYou can set validation attribute using the SetValidateAttribute method.\n\n\nclass ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            // Set validation attributes into the ReactiveProperty.\n            .SetValidateAttribute(() => Name);\n    }\n}\n\n\n\n\nWPF is integrated INotifyDataErrorInfo interface. See below.\n\n\n\n\nHandling validation errors\n\n\nAnother platform can't display error messages from the INofityDataErrorInfo interface.\nReactiveProperty class have some properties for handling validation errors.\n\n\nA first property is \nObserveErrorChanged\n.\nThis type is \nIObservable<IEnumerable>\n. You can convert to an error message from IEnumerable. See below.\n\n\nclass ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ReactiveProperty<string> NameErrorMessage { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            // Set validation attributes into the ReactiveProperty.\n            .SetValidateAttribute(() => Name);\n\n        // Handling an error message\n        NameErrorMessage = Name.ObserveErrorChanged\n            .Select(x => x?.OfType<string>()?.FirstOrDefault())\n            .ToReactiveProperty();\n    }\n}\n\n\n\n\nBind \nNameErrorMessage.Value\n property to a text control. An error message can be displayed.\n\n\nIn the case of UWP, see below.\n\n\npublic sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.NameErrorMessage.Value, Mode=OneWay}\"\n                   Foreground=\"Red\"\n                   Margin=\"5,0\"\n                   Style=\"{ThemeResource BodyTextBlockStyle}\" />\n    </StackPanel>\n</Page>\n\n\n\n\n\n\nNext property is \nObserveHasErrors\n. \nObserveHasErrors\n property type is \nIObservable<bool>\n.\nIn popular input form case, combine \nObserveHasErrors\n property values very useful.\n\n\nThis sample program is that create HasErros property that type is ReactiveProperty<bool> that combine two ReactiveProperty's ObserveHasErrors properties.\n\n\npublic class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    [Required(ErrorMessage = \"The memo is required.\")]\n    public ReactiveProperty<string> Memo { get; }\n\n    public ReactiveProperty<bool> HasErrors { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n\n        Memo = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Memo);\n\n        // You can combine some ObserveHasErrors values.\n        HasErrors = new[]\n            {\n                Name.ObserveHasErrors,\n                Memo.ObserveHasErrors,\n            }.CombineLatest(x => x.Any(y => y))\n            .ToReactiveProperty();\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\" \n                   Margin=\"5\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"Memo\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5\" />\n        <TextBox Text=\"{x:Bind ViewModel.Memo.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"HasErrors\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5\" />\n        <CheckBox IsChecked=\"{x:Bind ViewModel.HasErrors.Value, Mode=OneWay}\"\n                  IsEnabled=\"False\"\n                  Margin=\"5\" />\n    </StackPanel>\n</Page>\n\n\n\n\n\n\n\n\nLast property is \nHasErrors\n. It is a just bool property.\n\n\npublic class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n    }\n\n    public void DoSomething()\n    {\n        if (Name.HasErrors)\n        {\n            // invalid value case\n        }\n        else\n        {\n            // valid value case\n        }\n    }\n}\n\n\n\n\nDon't need initial validation error\n\n\nIn default behavior, ReactiveProperty report errors when validation logic set.\nIf you don't need initial validation error, then you can skip the error.\nJust call Skip method.\n\n\nclass ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ReactiveProperty<string> NameErrorMessage { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n\n        // Handling an error message\n        NameErrorMessage = Name.ObserveErrorChanged\n            .Skip(1) // Skip the first error.\n            .Select(x => x?.OfType<string>()?.FirstOrDefault())\n            .ToReactiveProperty();\n    }\n}\n\n\n\n\nThe mode of ReactiveProperty\n\n\nReactiveProperty class call OnNext callback when Subscribe method called.\n\n\nvar x = new ReactiveProperty<string>(\"initial value\");\nx.Subscribe(x => Console.WriteLine(x)); // -> initial value\n\n\n\n\nYou could change this behavior when ReactiveProperty instance create.\nConstructor and ToReactiveProperty method have mode argument.\nThis can be set following values.\n\n\n\n\nReactivePropertyMode.None\n\n\nReactiveProperty doesn't call OnNext callback when Subscribe method call. And call OnNext callback if the same value set.\n\n\n\n\n\n\nReactivePropertyMode.DistinctUntilChanged\n\n\nThis doesn't call OnNext callback if same value set.\n\n\n\n\n\n\nReactivePropertyMode.RaiseLatestValueOnSubscribe\n\n\nThis calls OnNext callback when Subscribe method call.\n\n\n\n\n\n\n\n\nDefault value is \nReactivePropertyMode.DistinctUntilChanged | ReactivePropertyMode.RaiseLatestValueOnSubscribe\n.\n\n\nIf you don't need this behavior, then you can set ReactivePropertyMode.None value.\n\n\nvar rp = new ReactiveProperty<string>(\"initial value\", mode: ReactivePropertyMode.None);\nrp.Subscribe(x => Console.WriteLine(x)); // -> don't output value\nrp.Value = \"initial value\"; // -> initial value\n\n\n\n\nForceNotify\n\n\nIf want to push the value forcibly, then can use the ForceNotify method.\nThis method pushes the value to subscribers, and raise a PropertyChanged event.\n\n\nvar rp = new ReactiveProperty<string>(\"value\");\nrp.Subscribe(x => Console.WriteLine(x));\nrp.PropertyChanged += (_, e) => Console.WriteLine($\"{e.PropertyName} changed\");\n\nrp.ForceNotify();\n\n\n\n\nOutput is as below.\n\n\nvalue                  # first subscribe\nvalue                  # by the ForceNotify method\nValue changed          # by the ForceNotify method\n\n\n\n\nChange comparer logic\n\n\nCan change comparer logic by the equalityComparer argument of constructor and factory methods.\n\n\nFor example, ignore case comparer:\n\n\nclass IgnoreCaseComparer : EqualityComparer<string>\n{\n    public override bool Equals(string x, string y)\n        => x?.ToLower() == y?.ToLower();\n\n    public override int GetHashCode(string obj)\n        => (obj?.ToLower()).GetHashCode();\n}\n\n// Constructor\nvar rp = new ReactiveProperty<string>(equalityComparer: new IgnoreCaseComparer());\nrp.Value = \"Hello world\"; // change to \"Hello world\" from null\nrp.Value = \"HELLO WORLD\"; // don't change\nrp.Value = \"Hello japan\"; // change to \"Hello japan\" from \"Hello world\"\n\n// Factory method\nvar source = new Subject<string>();\nvar rp = source.ToReactiveProperty(equalityComparer: new IgnoreCaseComparer());\nsource.OnNext(\"Hello world\"); // change to \"Hello world\" from null\nsource.OnNext(\"HELLO WORLD\"); // don't change\nsource.OnNext(\"Hello japan\"); // change to \"Hello japan\" from \"Hello world\"\n\n\n\n\nReadOnlyReactiveProperty class\n\n\nIf you never set Value property, then you can use ReadOnlyReactiveProperty class.\nThis class can't set the property, and other behavior is same ReactiveProperty class.\nReadOnlyReactiveProperty class is created from ToReadOnlyReactiveProperty extension method.\n\n\nSee below.\n\n\npublic class ViewModel\n{\n    public ReactiveProperty<string> Input { get; }\n\n    // Output never set value.\n    public ReadOnlyReactiveProperty<string> Output { get; }\n\n    public ViewModel()\n    {\n        Input = new ReactiveProperty<string>(\"\");\n        Output = Input\n            .Delay(TimeSpan.FromSeconds(1))\n            .Select(x => x.ToUpper())\n            .ToReadOnlyReactiveProperty(); // convert to ReadOnlyReactiveProperty\n    }\n}\n\n\n\n\nUnsubscribe\n\n\nReactiveProperty class implements IDisposable interface.\nWhen Dispose method called, ReactiveProperty class releases all subscription.\nIn other instance's events subscribe, then you should call Dispose method when the end of ViewModel lifecycle.\n\n\npublic class ViewModel : IDisposable\n{\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveProperty();\n    }\n\n    public void Dispose()\n    {\n        // Unsbscribe\n        Time.Dispose();\n    }\n}",
            "title": "ReactiveProperty"
        },
        {
            "location": "/features/ReactiveProperty/#use-with-xaml-platform",
            "text": "The ReactiveProperty class is designed for XAML platform which is like WPF, UWP, and Xamarin.Forms.\nThis class can be used a ViewModel layer.   In the case that don't use the ReactiveProperty, a ViewModel class wrote below.   public class MainPageViewModel : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string _name;\n    public string Name\n    {\n        get => _name;\n        set\n        {\n            _name = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n        }\n    }\n\n    // Other properties are defined similar codes.\n}  And those properties binds in the XAML code.  <!-- In the WPF -->\n<TextBox Text=\"{Binding Name}\" />\n\n<!-- In the UWP(Runtime data binding) -->\n<TextBox Text=\"{Binding Name}\" />\n\n<!-- In the UWP(Compile time data binding) -->\n<TextBox Text=\"{x:Bind ViewModel.Name, Mode=TwoWay}\" />\n\n<!-- In the Xamarin.Forms -->\n<Entry Text=\"{Binding Name}\" />  In the case that uses the ReactiveProperty, a ViewModel code becomes very simple!  // The INotifyPropertyChanged interface must implement when using the WPF.\n// Because, if you don't implement this, then memory leak occurred.\npublic class MainPageViewModel\n{\n    public ReactiveProperty<string> Name { get; } = new ReactiveProperty<string>();\n\n    // Other properties are defined similar codes.\n}  When binding in the XAML code, you must add the  .Value  in binding path.\nThis is an only limitation of this library.  <!-- In the WPF -->\n<TextBox Text=\"{Binding Name.Value}\" />\n\n<!-- In the UWP(Runtime data binding) -->\n<TextBox Text=\"{Binding Name.Value}\" />\n\n<!-- In the UWP(Compile time data binding) -->\n<TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay}\" />\n\n<!-- In the Xamarin.Forms -->\n<Entry Text=\"{Binding Name.Value}\" />   We forget the  .Value  sometimes. If you have a ReSharper license, then you can use this plugin. ReactiveProperty XAML Binding Corrector \nHighlight the missing of ReactiveProperty \".Value\" in XAML.",
            "title": "Use with XAML platform"
        },
        {
            "location": "/features/ReactiveProperty/#how-to-create-a-reactiveproperty-instance",
            "text": "The ReactiveProperty class can create from many methods.",
            "title": "How to create a ReactiveProperty instance"
        },
        {
            "location": "/features/ReactiveProperty/#create-from-the-constructor",
            "text": "The simplest way is that using constructor.  // create with the default value.\nvar name = new ReactiveProperty<string>();\nConsole.WriteLine(name.Value); // -> empty output\n\n// create with the initial value.\nvar name = new ReactiveProperty<string>(\"okazuki\");\nConsole.WriteLine(name.Value); // -> okazuki",
            "title": "Create from the constructor"
        },
        {
            "location": "/features/ReactiveProperty/#create-from-iobservablet",
            "text": "This can create from IObservable<T>.\nJust calls  ToReactiveProperty  method.  IObservable<long> observableInstance = Observable.Interval(TimeSpan.FromSeconds(1));\n\n// Convert to ReactiveProperty from IObservable.\nReactiveProperty<long> counter = observableInstance.ToReactiveProperty();",
            "title": "Create from IObservable&lt;T&gt;"
        },
        {
            "location": "/features/ReactiveProperty/#create-from-reactiveproperty",
            "text": "The ReactiveProperty implements IObservable interface.\nIt means that ReactiveProperty can be created from ReactiveProperty.  var name = new ReactiveProperty<string>(\"\");\n\nvar formalName = name.Select(x => $\"Dear {x}\")\n    .ToReactiveProperty();  All IObservable instances can become ReactiveProperty.",
            "title": "Create from ReactiveProperty"
        },
        {
            "location": "/features/ReactiveProperty/#validation",
            "text": "The ReactiveProperty class implements INotifyDataErrorInfo interface.",
            "title": "Validation"
        },
        {
            "location": "/features/ReactiveProperty/#set-custom-validation-logics",
            "text": "You can set custom validation logic using the SetValidateNotifyError method.  var name = new ReactiveProperty<string>()\n    .SetValidateNotifyError(x => string.IsNullOrWhiteSpace(x) ? \"Error message\" : null);  In the correct value case, validation logic should return null.\nIn invalid value case, logic should return an error message.",
            "title": "Set custom validation logics"
        },
        {
            "location": "/features/ReactiveProperty/#work-with-dataannotations",
            "text": "This class can work together with the DataAnnotations.\nYou can set validation attribute using the SetValidateAttribute method.  class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            // Set validation attributes into the ReactiveProperty.\n            .SetValidateAttribute(() => Name);\n    }\n}  WPF is integrated INotifyDataErrorInfo interface. See below.",
            "title": "Work with DataAnnotations"
        },
        {
            "location": "/features/ReactiveProperty/#handling-validation-errors",
            "text": "Another platform can't display error messages from the INofityDataErrorInfo interface.\nReactiveProperty class have some properties for handling validation errors.  A first property is  ObserveErrorChanged .\nThis type is  IObservable<IEnumerable> . You can convert to an error message from IEnumerable. See below.  class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ReactiveProperty<string> NameErrorMessage { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            // Set validation attributes into the ReactiveProperty.\n            .SetValidateAttribute(() => Name);\n\n        // Handling an error message\n        NameErrorMessage = Name.ObserveErrorChanged\n            .Select(x => x?.OfType<string>()?.FirstOrDefault())\n            .ToReactiveProperty();\n    }\n}  Bind  NameErrorMessage.Value  property to a text control. An error message can be displayed.  In the case of UWP, see below.  public sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.NameErrorMessage.Value, Mode=OneWay}\"\n                   Foreground=\"Red\"\n                   Margin=\"5,0\"\n                   Style=\"{ThemeResource BodyTextBlockStyle}\" />\n    </StackPanel>\n</Page>   Next property is  ObserveHasErrors .  ObserveHasErrors  property type is  IObservable<bool> .\nIn popular input form case, combine  ObserveHasErrors  property values very useful.  This sample program is that create HasErros property that type is ReactiveProperty<bool> that combine two ReactiveProperty's ObserveHasErrors properties.  public class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    [Required(ErrorMessage = \"The memo is required.\")]\n    public ReactiveProperty<string> Memo { get; }\n\n    public ReactiveProperty<bool> HasErrors { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n\n        Memo = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Memo);\n\n        // You can combine some ObserveHasErrors values.\n        HasErrors = new[]\n            {\n                Name.ObserveHasErrors,\n                Memo.ObserveHasErrors,\n            }.CombineLatest(x => x.Any(y => y))\n            .ToReactiveProperty();\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\" \n                   Margin=\"5\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"Memo\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5\" />\n        <TextBox Text=\"{x:Bind ViewModel.Memo.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"HasErrors\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5\" />\n        <CheckBox IsChecked=\"{x:Bind ViewModel.HasErrors.Value, Mode=OneWay}\"\n                  IsEnabled=\"False\"\n                  Margin=\"5\" />\n    </StackPanel>\n</Page>    Last property is  HasErrors . It is a just bool property.  public class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n    }\n\n    public void DoSomething()\n    {\n        if (Name.HasErrors)\n        {\n            // invalid value case\n        }\n        else\n        {\n            // valid value case\n        }\n    }\n}",
            "title": "Handling validation errors"
        },
        {
            "location": "/features/ReactiveProperty/#dont-need-initial-validation-error",
            "text": "In default behavior, ReactiveProperty report errors when validation logic set.\nIf you don't need initial validation error, then you can skip the error.\nJust call Skip method.  class ViewModel\n{\n    // Set validation attributes\n    [Required(ErrorMessage = \"The name is required.\")]\n    [StringLength(100, ErrorMessage = \"The name length should be lower than 30.\")]\n    public ReactiveProperty<string> Name { get; }\n\n    public ReactiveProperty<string> NameErrorMessage { get; }\n\n    public ViewModel()\n    {\n        Name = new ReactiveProperty<string>()\n            .SetValidateAttribute(() => Name);\n\n        // Handling an error message\n        NameErrorMessage = Name.ObserveErrorChanged\n            .Skip(1) // Skip the first error.\n            .Select(x => x?.OfType<string>()?.FirstOrDefault())\n            .ToReactiveProperty();\n    }\n}",
            "title": "Don't need initial validation error"
        },
        {
            "location": "/features/ReactiveProperty/#the-mode-of-reactiveproperty",
            "text": "ReactiveProperty class call OnNext callback when Subscribe method called.  var x = new ReactiveProperty<string>(\"initial value\");\nx.Subscribe(x => Console.WriteLine(x)); // -> initial value  You could change this behavior when ReactiveProperty instance create.\nConstructor and ToReactiveProperty method have mode argument.\nThis can be set following values.   ReactivePropertyMode.None  ReactiveProperty doesn't call OnNext callback when Subscribe method call. And call OnNext callback if the same value set.    ReactivePropertyMode.DistinctUntilChanged  This doesn't call OnNext callback if same value set.    ReactivePropertyMode.RaiseLatestValueOnSubscribe  This calls OnNext callback when Subscribe method call.     Default value is  ReactivePropertyMode.DistinctUntilChanged | ReactivePropertyMode.RaiseLatestValueOnSubscribe .  If you don't need this behavior, then you can set ReactivePropertyMode.None value.  var rp = new ReactiveProperty<string>(\"initial value\", mode: ReactivePropertyMode.None);\nrp.Subscribe(x => Console.WriteLine(x)); // -> don't output value\nrp.Value = \"initial value\"; // -> initial value",
            "title": "The mode of ReactiveProperty"
        },
        {
            "location": "/features/ReactiveProperty/#forcenotify",
            "text": "If want to push the value forcibly, then can use the ForceNotify method.\nThis method pushes the value to subscribers, and raise a PropertyChanged event.  var rp = new ReactiveProperty<string>(\"value\");\nrp.Subscribe(x => Console.WriteLine(x));\nrp.PropertyChanged += (_, e) => Console.WriteLine($\"{e.PropertyName} changed\");\n\nrp.ForceNotify();  Output is as below.  value                  # first subscribe\nvalue                  # by the ForceNotify method\nValue changed          # by the ForceNotify method",
            "title": "ForceNotify"
        },
        {
            "location": "/features/ReactiveProperty/#change-comparer-logic",
            "text": "Can change comparer logic by the equalityComparer argument of constructor and factory methods.  For example, ignore case comparer:  class IgnoreCaseComparer : EqualityComparer<string>\n{\n    public override bool Equals(string x, string y)\n        => x?.ToLower() == y?.ToLower();\n\n    public override int GetHashCode(string obj)\n        => (obj?.ToLower()).GetHashCode();\n}\n\n// Constructor\nvar rp = new ReactiveProperty<string>(equalityComparer: new IgnoreCaseComparer());\nrp.Value = \"Hello world\"; // change to \"Hello world\" from null\nrp.Value = \"HELLO WORLD\"; // don't change\nrp.Value = \"Hello japan\"; // change to \"Hello japan\" from \"Hello world\"\n\n// Factory method\nvar source = new Subject<string>();\nvar rp = source.ToReactiveProperty(equalityComparer: new IgnoreCaseComparer());\nsource.OnNext(\"Hello world\"); // change to \"Hello world\" from null\nsource.OnNext(\"HELLO WORLD\"); // don't change\nsource.OnNext(\"Hello japan\"); // change to \"Hello japan\" from \"Hello world\"",
            "title": "Change comparer logic"
        },
        {
            "location": "/features/ReactiveProperty/#readonlyreactiveproperty-class",
            "text": "If you never set Value property, then you can use ReadOnlyReactiveProperty class.\nThis class can't set the property, and other behavior is same ReactiveProperty class.\nReadOnlyReactiveProperty class is created from ToReadOnlyReactiveProperty extension method.  See below.  public class ViewModel\n{\n    public ReactiveProperty<string> Input { get; }\n\n    // Output never set value.\n    public ReadOnlyReactiveProperty<string> Output { get; }\n\n    public ViewModel()\n    {\n        Input = new ReactiveProperty<string>(\"\");\n        Output = Input\n            .Delay(TimeSpan.FromSeconds(1))\n            .Select(x => x.ToUpper())\n            .ToReadOnlyReactiveProperty(); // convert to ReadOnlyReactiveProperty\n    }\n}",
            "title": "ReadOnlyReactiveProperty class"
        },
        {
            "location": "/features/ReactiveProperty/#unsubscribe",
            "text": "ReactiveProperty class implements IDisposable interface.\nWhen Dispose method called, ReactiveProperty class releases all subscription.\nIn other instance's events subscribe, then you should call Dispose method when the end of ViewModel lifecycle.  public class ViewModel : IDisposable\n{\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveProperty();\n    }\n\n    public void Dispose()\n    {\n        // Unsbscribe\n        Time.Dispose();\n    }\n}",
            "title": "Unsubscribe"
        },
        {
            "location": "/features/ReactivePropertySlim/",
            "text": "ReactivePropertySlim\n\n\nReactivePropertySlim is a lightweight version ReactiveProperty.\n\n\nReactivePropertySlim provides following features:\n\n\n\n\nImplements INotifyPropertyChanged interface.\n\n\nImplements IObservable<T> interface.\n\n\nProvides a Value property.\n\n\nProvides a ForceNotify method.\n\n\n\n\nAnd ReactivePropertySlim is high performance.\n\n\nThis class can use like same as ReactiveProperty.\n\n\nvar rp = new ReactivePropertySlim<string>(\"neuecc\");\nrp.Select(x => $\"{x}-san\").Subscribe(x => Console.WriteLine(x));\nrp.Value = \"xin9le\";\nrp.Value = \"okazuki\";\n\n\n\n\nOutput is as below.\n\n\nneuecc-san\nxin9le-san\nokazuki-san\n\n\n\n\nOne different which compare the ReactiveProperty is that ReactivePropertySlim can't create from IObservable<T>.\n\n\n// It isn't valid code.\nvar rp = Observable.Interval(TimeSpan.FromSeconds(1)).ToReactivePropertySlim();\n\n\n\n\nIf want to create Slim class's instance from IObservable<T>, then use the ToReadOnlyReactivePropertySlim extension method.\n\n\nvar rp = Observable.Interval(TimeSpan.FromSeconds(1)).ToReadOnlyReactivePropertySlim();\n\n\n\n\nDispatch to UI thread\n\n\nReactivePropertySlim class doesn't dispatch to UI thread automaticaly.\nIf want this feature, then use the ReactiveProperty or dispatch to UI thread expressly.\n\n\nvar rp = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ObserveOnUIDispatcher() // dispatch to UI thread\n    .ToReadOnlyReactivePropertySlim();\n\n\n\n\nValidation\n\n\nSlim class doesn't provide the validation feature.\nIf want to this feature, then use to ReactiveProperty class.",
            "title": "ReactivePropertySlim"
        },
        {
            "location": "/features/ReactivePropertySlim/#reactivepropertyslim",
            "text": "ReactivePropertySlim is a lightweight version ReactiveProperty.  ReactivePropertySlim provides following features:   Implements INotifyPropertyChanged interface.  Implements IObservable<T> interface.  Provides a Value property.  Provides a ForceNotify method.   And ReactivePropertySlim is high performance.  This class can use like same as ReactiveProperty.  var rp = new ReactivePropertySlim<string>(\"neuecc\");\nrp.Select(x => $\"{x}-san\").Subscribe(x => Console.WriteLine(x));\nrp.Value = \"xin9le\";\nrp.Value = \"okazuki\";  Output is as below.  neuecc-san\nxin9le-san\nokazuki-san  One different which compare the ReactiveProperty is that ReactivePropertySlim can't create from IObservable<T>.  // It isn't valid code.\nvar rp = Observable.Interval(TimeSpan.FromSeconds(1)).ToReactivePropertySlim();  If want to create Slim class's instance from IObservable<T>, then use the ToReadOnlyReactivePropertySlim extension method.  var rp = Observable.Interval(TimeSpan.FromSeconds(1)).ToReadOnlyReactivePropertySlim();",
            "title": "ReactivePropertySlim"
        },
        {
            "location": "/features/ReactivePropertySlim/#dispatch-to-ui-thread",
            "text": "ReactivePropertySlim class doesn't dispatch to UI thread automaticaly.\nIf want this feature, then use the ReactiveProperty or dispatch to UI thread expressly.  var rp = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ObserveOnUIDispatcher() // dispatch to UI thread\n    .ToReadOnlyReactivePropertySlim();",
            "title": "Dispatch to UI thread"
        },
        {
            "location": "/features/ReactivePropertySlim/#validation",
            "text": "Slim class doesn't provide the validation feature.\nIf want to this feature, then use to ReactiveProperty class.",
            "title": "Validation"
        },
        {
            "location": "/features/Commanding/",
            "text": "ReactiveCommand class implements following two interfaces.\n\n\n\n\nICommand interface\n\n\nIObservable<T>\n\n\n\n\nBasic usage\n\n\nThis class can be created using ToReactiveCommand extension method from IObservable<bool> instance.\nWhen IObservable<bool> instance updated, CanExecuteChanged event raise.\n\n\nIf you always want executable command, then you can create ReactiveCommand instance using the default constructor.\n\n\nIObservable<bool> canExecuteSource = ...;\n\nReactiveCommand someCommand = canExecuteSource.ToReactiveCommand(); // non command parameter version.\nReactiveCommand<string> hasCommandParameterCommand = canExecuteSource.ToReactiveCommand<string>(); // has command parameter version\nReactiveCommand alwaysExecutableCommand = new ReactiveCommand(); // non command parameter and always can execute version.\nReactiveCommand<string> alwaysExecutableAndHasCommandParameterCommand = new ReactiveCommand<string>(); // has command parameter and always can execute version.\n\n\n\n\nAnd you can set the initial return value of CanExecute method using factory extension method's initalValue argument.\nThe default value is true.\n\n\nIObservable<bool> canExecuteSource = ...;\n\nReactiveCommand someCommand = canExecuteSource.ToReactiveCommand(false);\nReactiveCommand<string> hasCommandParameterCommand = canExecuteSource.ToReactiveCommand<string>(false);\n\n\n\n\nWhen Execute method is called, ReactiveCommand call the OnNext callback.\nYou can register execute logic using the Subscribe method.\n\n\nReactiveCommand someCommand = new ReactiveCommand();\nsomeCommand.Subscribe(_ => { ... some logic ... }); // set an OnNext callback\n\nsomeCommand.Execute(); // OnNext callback is called.\n\n\n\n\nUsing in ViewModel class\n\n\nThe first example, just use ReactiveCommand class.\n\n\npublic class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = new ReactiveProperty<string>();\n        UpdateTimeCommand = new ReactiveCommand();\n        UpdateTimeCommand.Subscribe(_ => Time.Value = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"));\n    }\n}\n\n\n\n\nUWP platform example.\n\n\npublic sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"Update the time\"\n                Command=\"{x:Bind ViewModel.UpdateTimeCommand}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Time.Value, Mode=OneWay}\"\n                   Style=\"{ThemeResource BodyTextBlockStyle}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Page>\n\n\n\n\n\n\nWork with LINQ\n\n\nReactiveCommand class implements IObservable<T> interface. \nCan use LINQ methods, and ReactiveProperty<T> class can create from IObservable<T>.\nYes, can change the previous example code to below.\n\n\npublic class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    // Don't need that set Value property. So can change to ReadOnlyReactiveProperty.\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        UpdateTimeCommand = new ReactiveCommand();\n        Time = UpdateTimeCommand\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveProperty();\n    }\n}\n\n\n\n\nCreate from IObservable<bool>\n\n\nChange to that the UpdateTimeCommand don't invoke during 5 secs after the command invoked.\n\n\npublic class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        var updateTimeTrigger = new Subject<Unit>();\n        UpdateTimeCommand = Observable.Merge(\n            updateTimeTrigger.Select(_ => false),\n            updateTimeTrigger.Delay(TimeSpan.FromSeconds(5)).Select(_ => true))\n            .ToReactiveCommand();\n        Time = UpdateTimeCommand\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .Do(_ => updateTimeTrigger.OnNext(Unit.Default))\n            .ToReadOnlyReactiveProperty();\n    }\n}\n\n\n\n\n\n\nCreate command and subscribe, in one statement\n\n\nIn the case that doesn't use LINQ methods, can create command and subscribe, in one statement.\nWithSubscribe extension method subscribes and return ReactiveCommand instance, see below.\n\n\npublic class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = new ReactiveProperty<string>();\n\n        var updateTimeTrigger = new Subject<Unit>();\n        UpdateTimeCommand = Observable.Merge(\n            updateTimeTrigger.Select(_ => false),\n            updateTimeTrigger.Delay(TimeSpan.FromSeconds(5)).Select(_ => true))\n            .ToReactiveCommand()\n            .WithSubscribe(() => Time.Value = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\")); // here\n    }\n}\n\n\n\n\nWithSubscribe method is a just shortcut below code.\n\n\n// No use the WithSubscribe\nvar command = new ReactiveCommand();\ncommand.Subscribe(_ => { ... some actions ... });\n\n// Use the WithSubscribe\nvar command = new ReactiveCommand()\n    .WithSubscribe(() => { ... some actions ... });\n\n\n\n\nIf use LINQ methods, then separate statements create an instance and subscribe.\n\n\nUnsubscribe actions\n\n\nIf need that unsubscribes actions, then use Dispose method of IDisposable which Subscribe method returned.\n\n\nvar command = new ReactiveCommand();\nvar subscription1 = command.Subscribe(_ => { ... some actions ... });\nvar subscription2 = command.Subscribe(_ => { ... some actions ... });\n\n// Unsubscribe per Subscribe method.\nsubscription1.Dispose();\nsubscription2.Dispose();\n\n// Unsubscribe all\ncommand.Dispose();\n\n\n\n\nWithSubscribe extension method has override methods which have an IDisposable argument.\n\n\nIDisposable subscription = null;\nvar command = new ReactiveCommand().WithSubscribe(() => { ... some actions ... }, out subscription);\n\n// Unsubscribe\nsubscription.Dispose();\n\n\n\n\nAnd has another override of Action\n argument.\nIt is used together with CompositeDisposable class.\n\n\nvar subscriptions = new CompositeDisposable();\nvar command = new ReactiveCommand()\n    .WithSubscribe(() => { ... some actions ... }, subscriptions.Add)\n    .WithSubscribe(() => { ... some actions ... }, subscriptions.Add);\n\n// Unsubscribe\nsubscription.Dispose();\n\n\n\n\nIn other instance's events subscribe, then you should call the Dispose method of ReactiveCommand class when the end of ViewModel lifecycle.\n\n\nAsync version ReactiveCommand\n\n\nAsyncReactiveCommand class is async version ReactiveCommand class.\nThis class can subscribe async methods, and when executing async method then CanExecute method returns false.\nSo, this class can't re-execute during the async method is proceed.\n\n\nBasic usage\n\n\nNeary the same as a ReactiveCommand class. \nJust difference is that accept async method in Subscribe method argument, and don't implement the IObservable<T> interface.\n\n\npublic class ViewModel\n{\n    public AsyncReactiveCommand HeavyCommand { get; }\n\n    public ReactiveProperty<string> Message { get; } = new ReactiveProperty<string>();\n\n    public ViewModel()\n    {\n        HeavyCommand = new AsyncReactiveCommand()\n            .WithSubscribe(async () =>\n            {\n                Message.Value = \"Heavy command started.\";\n                await Task.Delay(TimeSpan.FromSeconds(5));\n                Message.Value = \"Heavy command finished.\";\n            });\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"Heavy command\"\n                Command=\"{x:Bind ViewModel.HeavyCommand}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Message.Value, Mode=OneWay}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Page>\n\n\n\n\n\n\nOf cause, AsyncReactiveCommand is created from IObservable<bool>.\n\n\npublic class ViewModel\n{\n    public AsyncReactiveCommand HeavyCommand { get; }\n\n    public ReactiveProperty<string> Message { get; } = new ReactiveProperty<string>();\n\n    public ViewModel()\n    {\n        HeavyCommand = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Select(x => x % 2 == 0)\n            .ToAsyncReactiveCommand()\n            .WithSubscribe(async () =>\n            {\n                Message.Value = \"Heavy command started.\";\n                await Task.Delay(TimeSpan.FromSeconds(5));\n                Message.Value = \"Heavy command finished.\";\n            });\n    }\n}\n\n\n\n\n\n\nAnd AsyncReactiveCommand implements the IDisposable interface.\nYou should call the Dispose method when the another instance's event subscribe.\n\n\nShare CanExecute state\n\n\nSometimes want only one of an async method is executing in a page.\nIn this case, can share CanExecute state between AsyncReactiveCommand instances.\nWhen created from a same ReactiveProperty<bool> instance, then synchronize CanExecute state.\n\n\npublic class ViewModel\n{\n    private ReactiveProperty<bool> HeavyCommandCanExecuteState { get; } = new ReactiveProperty<bool>(true);\n    public AsyncReactiveCommand HeavyCommand1 { get; }\n    public AsyncReactiveCommand HeavyCommand2 { get; }\n\n    public ReactiveProperty<string> Message { get; } = new ReactiveProperty<string>();\n\n    public ViewModel()\n    {\n        HeavyCommand1 = HeavyCommandCanExecuteState\n            .ToAsyncReactiveCommand()\n            .WithSubscribe(async () =>\n            {\n                Message.Value = \"Heavy command 1 started.\";\n                await Task.Delay(TimeSpan.FromSeconds(5));\n                Message.Value = \"Heavy command 1 finished.\";\n            });\n        HeavyCommand2 = HeavyCommandCanExecuteState\n            .ToAsyncReactiveCommand()\n            .WithSubscribe(async () =>\n            {\n                Message.Value = \"Heavy command 2 started.\";\n                await Task.Delay(TimeSpan.FromSeconds(5));\n                Message.Value = \"Heavy command 2 finished.\";\n            });\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"Heavy command 1\"\n                Command=\"{x:Bind ViewModel.HeavyCommand1}\"\n                Margin=\"5\" />\n        <Button Content=\"Heavy command 2\"\n                Command=\"{x:Bind ViewModel.HeavyCommand2}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Message.Value, Mode=OneWay}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Page>",
            "title": "Commanding"
        },
        {
            "location": "/features/Commanding/#basic-usage",
            "text": "This class can be created using ToReactiveCommand extension method from IObservable<bool> instance.\nWhen IObservable<bool> instance updated, CanExecuteChanged event raise.  If you always want executable command, then you can create ReactiveCommand instance using the default constructor.  IObservable<bool> canExecuteSource = ...;\n\nReactiveCommand someCommand = canExecuteSource.ToReactiveCommand(); // non command parameter version.\nReactiveCommand<string> hasCommandParameterCommand = canExecuteSource.ToReactiveCommand<string>(); // has command parameter version\nReactiveCommand alwaysExecutableCommand = new ReactiveCommand(); // non command parameter and always can execute version.\nReactiveCommand<string> alwaysExecutableAndHasCommandParameterCommand = new ReactiveCommand<string>(); // has command parameter and always can execute version.  And you can set the initial return value of CanExecute method using factory extension method's initalValue argument.\nThe default value is true.  IObservable<bool> canExecuteSource = ...;\n\nReactiveCommand someCommand = canExecuteSource.ToReactiveCommand(false);\nReactiveCommand<string> hasCommandParameterCommand = canExecuteSource.ToReactiveCommand<string>(false);  When Execute method is called, ReactiveCommand call the OnNext callback.\nYou can register execute logic using the Subscribe method.  ReactiveCommand someCommand = new ReactiveCommand();\nsomeCommand.Subscribe(_ => { ... some logic ... }); // set an OnNext callback\n\nsomeCommand.Execute(); // OnNext callback is called.",
            "title": "Basic usage"
        },
        {
            "location": "/features/Commanding/#using-in-viewmodel-class",
            "text": "The first example, just use ReactiveCommand class.  public class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = new ReactiveProperty<string>();\n        UpdateTimeCommand = new ReactiveCommand();\n        UpdateTimeCommand.Subscribe(_ => Time.Value = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"));\n    }\n}  UWP platform example.  public sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"Update the time\"\n                Command=\"{x:Bind ViewModel.UpdateTimeCommand}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Time.Value, Mode=OneWay}\"\n                   Style=\"{ThemeResource BodyTextBlockStyle}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Page>",
            "title": "Using in ViewModel class"
        },
        {
            "location": "/features/Commanding/#work-with-linq",
            "text": "ReactiveCommand class implements IObservable<T> interface. \nCan use LINQ methods, and ReactiveProperty<T> class can create from IObservable<T>.\nYes, can change the previous example code to below.  public class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    // Don't need that set Value property. So can change to ReadOnlyReactiveProperty.\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        UpdateTimeCommand = new ReactiveCommand();\n        Time = UpdateTimeCommand\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveProperty();\n    }\n}",
            "title": "Work with LINQ"
        },
        {
            "location": "/features/Commanding/#create-from-iobservablebool",
            "text": "Change to that the UpdateTimeCommand don't invoke during 5 secs after the command invoked.  public class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReadOnlyReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        var updateTimeTrigger = new Subject<Unit>();\n        UpdateTimeCommand = Observable.Merge(\n            updateTimeTrigger.Select(_ => false),\n            updateTimeTrigger.Delay(TimeSpan.FromSeconds(5)).Select(_ => true))\n            .ToReactiveCommand();\n        Time = UpdateTimeCommand\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .Do(_ => updateTimeTrigger.OnNext(Unit.Default))\n            .ToReadOnlyReactiveProperty();\n    }\n}",
            "title": "Create from IObservable&lt;bool&gt;"
        },
        {
            "location": "/features/Commanding/#create-command-and-subscribe-in-one-statement",
            "text": "In the case that doesn't use LINQ methods, can create command and subscribe, in one statement.\nWithSubscribe extension method subscribes and return ReactiveCommand instance, see below.  public class ViewModel\n{\n    public ReactiveCommand UpdateTimeCommand { get; }\n\n    public ReactiveProperty<string> Time { get; }\n\n    public ViewModel()\n    {\n        Time = new ReactiveProperty<string>();\n\n        var updateTimeTrigger = new Subject<Unit>();\n        UpdateTimeCommand = Observable.Merge(\n            updateTimeTrigger.Select(_ => false),\n            updateTimeTrigger.Delay(TimeSpan.FromSeconds(5)).Select(_ => true))\n            .ToReactiveCommand()\n            .WithSubscribe(() => Time.Value = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\")); // here\n    }\n}  WithSubscribe method is a just shortcut below code.  // No use the WithSubscribe\nvar command = new ReactiveCommand();\ncommand.Subscribe(_ => { ... some actions ... });\n\n// Use the WithSubscribe\nvar command = new ReactiveCommand()\n    .WithSubscribe(() => { ... some actions ... });  If use LINQ methods, then separate statements create an instance and subscribe.",
            "title": "Create command and subscribe, in one statement"
        },
        {
            "location": "/features/Commanding/#unsubscribe-actions",
            "text": "If need that unsubscribes actions, then use Dispose method of IDisposable which Subscribe method returned.  var command = new ReactiveCommand();\nvar subscription1 = command.Subscribe(_ => { ... some actions ... });\nvar subscription2 = command.Subscribe(_ => { ... some actions ... });\n\n// Unsubscribe per Subscribe method.\nsubscription1.Dispose();\nsubscription2.Dispose();\n\n// Unsubscribe all\ncommand.Dispose();  WithSubscribe extension method has override methods which have an IDisposable argument.  IDisposable subscription = null;\nvar command = new ReactiveCommand().WithSubscribe(() => { ... some actions ... }, out subscription);\n\n// Unsubscribe\nsubscription.Dispose();  And has another override of Action  argument.\nIt is used together with CompositeDisposable class.  var subscriptions = new CompositeDisposable();\nvar command = new ReactiveCommand()\n    .WithSubscribe(() => { ... some actions ... }, subscriptions.Add)\n    .WithSubscribe(() => { ... some actions ... }, subscriptions.Add);\n\n// Unsubscribe\nsubscription.Dispose();  In other instance's events subscribe, then you should call the Dispose method of ReactiveCommand class when the end of ViewModel lifecycle.",
            "title": "Unsubscribe actions"
        },
        {
            "location": "/features/Commanding/#async-version-reactivecommand",
            "text": "AsyncReactiveCommand class is async version ReactiveCommand class.\nThis class can subscribe async methods, and when executing async method then CanExecute method returns false.\nSo, this class can't re-execute during the async method is proceed.",
            "title": "Async version ReactiveCommand"
        },
        {
            "location": "/features/Commanding/#basic-usage_1",
            "text": "Neary the same as a ReactiveCommand class. \nJust difference is that accept async method in Subscribe method argument, and don't implement the IObservable<T> interface.  public class ViewModel\n{\n    public AsyncReactiveCommand HeavyCommand { get; }\n\n    public ReactiveProperty<string> Message { get; } = new ReactiveProperty<string>();\n\n    public ViewModel()\n    {\n        HeavyCommand = new AsyncReactiveCommand()\n            .WithSubscribe(async () =>\n            {\n                Message.Value = \"Heavy command started.\";\n                await Task.Delay(TimeSpan.FromSeconds(5));\n                Message.Value = \"Heavy command finished.\";\n            });\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"Heavy command\"\n                Command=\"{x:Bind ViewModel.HeavyCommand}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Message.Value, Mode=OneWay}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Page>   Of cause, AsyncReactiveCommand is created from IObservable<bool>.  public class ViewModel\n{\n    public AsyncReactiveCommand HeavyCommand { get; }\n\n    public ReactiveProperty<string> Message { get; } = new ReactiveProperty<string>();\n\n    public ViewModel()\n    {\n        HeavyCommand = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Select(x => x % 2 == 0)\n            .ToAsyncReactiveCommand()\n            .WithSubscribe(async () =>\n            {\n                Message.Value = \"Heavy command started.\";\n                await Task.Delay(TimeSpan.FromSeconds(5));\n                Message.Value = \"Heavy command finished.\";\n            });\n    }\n}   And AsyncReactiveCommand implements the IDisposable interface.\nYou should call the Dispose method when the another instance's event subscribe.",
            "title": "Basic usage"
        },
        {
            "location": "/features/Commanding/#share-canexecute-state",
            "text": "Sometimes want only one of an async method is executing in a page.\nIn this case, can share CanExecute state between AsyncReactiveCommand instances.\nWhen created from a same ReactiveProperty<bool> instance, then synchronize CanExecute state.  public class ViewModel\n{\n    private ReactiveProperty<bool> HeavyCommandCanExecuteState { get; } = new ReactiveProperty<bool>(true);\n    public AsyncReactiveCommand HeavyCommand1 { get; }\n    public AsyncReactiveCommand HeavyCommand2 { get; }\n\n    public ReactiveProperty<string> Message { get; } = new ReactiveProperty<string>();\n\n    public ViewModel()\n    {\n        HeavyCommand1 = HeavyCommandCanExecuteState\n            .ToAsyncReactiveCommand()\n            .WithSubscribe(async () =>\n            {\n                Message.Value = \"Heavy command 1 started.\";\n                await Task.Delay(TimeSpan.FromSeconds(5));\n                Message.Value = \"Heavy command 1 finished.\";\n            });\n        HeavyCommand2 = HeavyCommandCanExecuteState\n            .ToAsyncReactiveCommand()\n            .WithSubscribe(async () =>\n            {\n                Message.Value = \"Heavy command 2 started.\";\n                await Task.Delay(TimeSpan.FromSeconds(5));\n                Message.Value = \"Heavy command 2 finished.\";\n            });\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"Heavy command 1\"\n                Command=\"{x:Bind ViewModel.HeavyCommand1}\"\n                Margin=\"5\" />\n        <Button Content=\"Heavy command 2\"\n                Command=\"{x:Bind ViewModel.HeavyCommand2}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"{x:Bind ViewModel.Message.Value, Mode=OneWay}\"\n                   Margin=\"5\" />\n    </StackPanel>\n</Page>",
            "title": "Share CanExecute state"
        },
        {
            "location": "/features/Collections/",
            "text": "ReactiveProperty provides some collection classes.\n\n\n\n\nReactiveCollection<T>\n\n\nReadOnlyReactiveCollection<T>\n\n\nIFilteredReadOnlyObservableCollection<T>\n\n\n\n\nReactiveCollection\n\n\nReactiveCollection hnherits ObservableCollection.\nThis class is created from IObservable.\nAnd adds an item when push a value from source IObservable.\nReactiveCollection executes this process using IScheduler. Default scheduler run process on the UI thread.\n\n\npublic class ViewModel\n{\n    public ReactiveCollection<DateTime> Records { get; }\n\n    public ReactiveCommand StartRecordCommand { get; }\n\n    public ViewModel()\n    {\n        StartRecordCommand = new ReactiveCommand();\n        // Create a ReactiveCollection instance from IObservable\n        Records = StartRecordCommand\n            .ToUnit()\n            .Take(1)\n            .Concat(Observable.Defer(() => Observable.Interval(TimeSpan.FromSeconds(1)).ToUnit()))\n            .Select(_ => DateTime.Now)\n            .ToReactiveCollection();\n    }\n}\n\n\n\n\n\n\nToUnit extension method is defined in the Reactive.Bindings.Extensions namespace.\nThis extension method is same as \n.Select(_ => Unide.Default)\n.\n\n\n\n\nExample of UWP platform.\n\n\nMainPage.xaml.cs\n\n\npublic sealed partial class MainPage : Page\n{\n    public ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}\n\n\n\n\nMainPage.xaml\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <StackPanel Orientation=\"Horizontal\">\n            <Button Content=\"Start\"\n                    Command=\"{x:Bind ViewModel.StartRecordCommand}\"\n                    Margin=\"5\" />\n        </StackPanel>\n        <ListView ItemsSource=\"{x:Bind ViewModel.Records}\"\n                  Grid.Row=\"1\" />\n    </Grid>\n</Page>\n\n\n\n\n\n\nCollection operations\n\n\nReactiveCollection class has XxxxOnScheduler methods. For example, AddOnScheduler, RemoveOnScheduler, ClearOnScheduler, GetOnScheduler, etc...\nThose methods are run on the IScheduler.\n\n\nCan call from outside of UI thread.\n\n\npublic class ViewModel\n{\n    public ReactiveCollection<DateTime> Records { get; }\n\n    public ReactiveCommand StartRecordCommand { get; }\n\n    public ReactiveCommand ClearCommand { get; }\n\n    public ViewModel()\n    {\n        StartRecordCommand = new ReactiveCommand();\n        // Create a ReactiveCollection instance from IObservable\n        Records = StartRecordCommand\n            .ToUnit()\n            .Take(1)\n            .Concat(Observable.Defer(() => Observable.Interval(TimeSpan.FromSeconds(1)).ToUnit()))\n            .Select(_ => DateTime.Now)\n            .ToReactiveCollection();\n\n        ClearCommand = new ReactiveCommand();\n        ClearCommand.ObserveOn(TaskPoolScheduler.Default) // run on the another thread\n            .Subscribe(_ => Records.ClearOnScheduler());\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <StackPanel Orientation=\"Horizontal\">\n            <Button Content=\"Start\"\n                    Command=\"{x:Bind ViewModel.StartRecordCommand}\"\n                    Margin=\"5\" />\n            <Button Content=\"Clear\"\n                    Command=\"{x:Bind ViewModel.ClearCommand}\"\n                    Margin=\"5\" />\n        </StackPanel>\n        <ListView ItemsSource=\"{x:Bind ViewModel.Records}\"\n                  Grid.Row=\"1\" />\n    </Grid>\n</Page>\n\n\n\n\n\n\nWhen ReactiveCollection class was called Dispose method, then unsubscribe the source IObservable instance.\n\n\nReadOnlyReactiveCollection\n\n\nReadOnlyReactiveCollection class provides one-way synchronization from ObservableCollection. Can set a converting logic, and dispatch CollectionChanged event raise on the IScheduler. Default IScheduler dispatch to the UI thread.\n\n\nAt first, exist a POCO classes.\n\n\npublic class BindableBase : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    protected void RaisePropertyChanged([CallerMemberName]string propertyName = null) =>\n        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n\n    protected void SetProperty<T>(ref T field, T value, [CallerMemberName]string propertyName = null)\n    {\n        if (EqualityComparer<T>.Default.Equals(field, value))\n        {\n            return;\n        }\n\n        field = value;\n        RaisePropertyChanged(propertyName);\n    }\n}\n\npublic class TimerObject : BindableBase, IDisposable\n{\n    private IDisposable Disposable { get; }\n\n    private long _count;\n    public long Count\n    {\n        get { return _count; }\n        private set { SetProperty(ref _count, value); }\n    }\n\n    public TimerObject()\n    {\n        Disposable = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Subscribe(_ => Count++);\n    }\n\n    public void Dispose()\n    {\n        Disposable.Dispose();\n    }\n}\n\n\n\n\nThis is a simple class that counts up the Count property per second.\n\n\nWrap the class to ViewModel layer using ReactiveProperty.\n\n\npublic class TimerObjectViewModel : IDisposable\n{\n    public TimerObject Model { get; }\n\n    public ReadOnlyReactiveProperty<string> CountMessage { get; }\n\n    public TimerObjectViewModel(TimerObject timerObject)\n    {\n        Model = timerObject;\n        CountMessage = Model.ObserveProperty(x => x.Count)\n            .Select(x => $\"Count value is {x}.\")\n            .ToReadOnlyReactiveProperty();\n    }\n\n    public void Dispose()\n    {\n        Model.Dispose();\n    }\n}\n\n\n\n\nManage TimerObject instances using the ObservableCollection.\nWe should provide TimerObjectViewModel instances to View layer, can use ReadOnlyReactiveCollection class.\nReadOnlyReactiveCollection instance is created using ToReadOnlyReactiveCollection extension method. \n\n\npublic class ViewModel\n{\n    // TimerObject collection\n    private ReactiveCollection<TimerObject> ModelCollection { get; }\n    // TimerObjectViewModel collection\n    public ReadOnlyReactiveCollection<TimerObjectViewModel> ViewModelCollection { get; }\n\n    public ReactiveCommand AddCommand { get; }\n\n    public ReactiveCommand<TimerObjectViewModel> RemoveCommand { get; }\n\n    public ViewModel()\n    {\n        AddCommand = new ReactiveCommand();\n        ModelCollection = AddCommand\n            .Select(_ => new TimerObject())\n            .ToReactiveCollection();\n        // Create a ReadOnlyReactiveCollection instance using the converting logic.\n        ViewModelCollection = ModelCollection\n            .ToReadOnlyReactiveCollection(x => new TimerObjectViewModel(x));\n\n        RemoveCommand = new ReactiveCommand<TimerObjectViewModel>()\n            .WithSubscribe(x => ModelCollection.Remove(x.Model));\n    }\n}\n\n\n\n\nTest view is below.\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      xmlns:viewModels=\"using:ViewModels\"\n      mc:Ignorable=\"d\"\n      x:Name=\"root\">\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <Button Content=\"Add\"\n                Command=\"{x:Bind ViewModel.AddCommand}\"\n                Margin=\"5\" />\n        <ListView ItemsSource=\"{x:Bind ViewModel.ViewModelCollection}\"\n                  Grid.Row=\"1\">\n            <ListView.ItemTemplate>\n                <DataTemplate x:DataType=\"viewModels:TimerObjectViewModel\">\n                    <Grid>\n                        <Grid.ColumnDefinitions>\n                            <ColumnDefinition Width=\"Auto\" />\n                            <ColumnDefinition />\n                        </Grid.ColumnDefinitions>\n                        <Button Content=\"Remove\"\n                                Command=\"{Binding ViewModel.RemoveCommand, ElementName=root}\"\n                                CommandParameter=\"{x:Bind}\"\n                                Margin=\"5\" />\n                        <TextBlock Text=\"{x:Bind CountMessage.Value, Mode=OneWay}\"\n                                   VerticalAlignment=\"Center\"\n                                   Style=\"{ThemeResource BodyTextBlockStyle}\"\n                                   Grid.Column=\"1\" />\n                    </Grid>\n                </DataTemplate>\n            </ListView.ItemTemplate>\n        </ListView>\n    </Grid>\n</Page>\n\n\n\n\n\n\nWhen the instance was removed in the ReadOnlyReactiveCollection, then the Dispose method is called. If don't need this behavior, then set false the ToReadOnlyReactiveCollection's disposeElement argument.\n\n\nViewModelCollection = ModelCollection\n    .ToReadOnlyReactiveCollection(x => new TimerObjectViewModel(x), disposeElement: false);\n\n\n\n\nCreate from IObservable\n\n\nReadOnlyReactiveCollection can create from IObservable, it is same as the ReactiveCollection. But, ReadOnlyReactiveCollection doesn't have collection operation methods.\nToReadOnlyReactiveCollection extension method has a onReset argument which type is IObservable<Unity>.\nWhen this argument raises value, then the collection is cleared.\n\n\npublic class ViewModel\n{\n    public ReadOnlyReactiveCollection<string> Messages { get; }\n\n    public ReactiveCommand ResetCommand { get; }\n\n    public ViewModel()\n    {\n        ResetCommand = new ReactiveCommand();\n        Messages = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveCollection(ResetCommand.ToUnit());\n    }\n}\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <Button Content=\"Reset\"\n                Command=\"{x:Bind ViewModel.ResetCommand}\"\n                Margin=\"5\" />\n        <ListView ItemsSource=\"{x:Bind ViewModel.Messages}\"\n                  Grid.Row=\"1\" />\n    </Grid>\n</Page>\n\n\n\n\nWhen the ResetCommand execute, then clear the Messages.\n\n\n\n\nIFilteredReadOnlyObservableCollection\n\n\nThis provides collection which filter realtime from ObservableCollection.\nIFilteredReadOnlyObservableCollection watch the PropertyChanged event of source collection item and the CollectionChanged event.\n\n\npublic class ValueHolder : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    public int Id { get; set; }\n\n    private int _value;\n    public int Value\n    {\n        get => _value;\n        set\n        {\n            _value = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Value)));\n        }\n    }\n\n    public ValueHolder()\n    {\n        var r = new Random();\n        Observable.Interval(TimeSpan.FromSeconds(1))\n            .ObserveOnUIDispatcher()\n            .Subscribe(_ => Value = r.Next(10));\n    }\n}\n\npublic class ViewModel\n{\n    public ReactiveCollection<ValueHolder> ValuesSource { get; }\n\n    public IFilteredReadOnlyObservableCollection<ValueHolder> Values { get; }\n\n    public ReactiveCommand AddCommand { get; }\n\n    public ViewModel()\n    {\n        AddCommand = new ReactiveCommand();\n        ValuesSource = AddCommand\n            .Select(_ => new ValueHolder { Id = ValuesSource.Count })\n            .ToReactiveCollection();\n        Values = ValuesSource.ToFilteredReadOnlyObservableCollection(\n            x => x.Value > 7);\n    }\n}\n\n\n\n\n\n\nObserveOnUIDispatcher extension method switch to the UI thread from the current thread.\n\n\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      xmlns:viewModels=\"using:ViewModels\"\n      mc:Ignorable=\"d\"\n      x:Name=\"root\">\n    <Page.Resources>\n        <DataTemplate x:Key=\"valueHolderDataTemplate\"\n                      x:DataType=\"viewModels:ValueHolder\">\n            <TextBlock>\n                <Run Text=\"Id: \" />\n                <Run Text=\"{x:Bind Id}\" />\n                <Run Text=\", Value: \" />\n                <Run Text=\"{x:Bind Value, Mode=OneWay}\" />\n            </TextBlock>\n        </DataTemplate>\n    </Page.Resources>\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <Grid.ColumnDefinitions>\n            <ColumnDefinition />\n            <ColumnDefinition />\n        </Grid.ColumnDefinitions>\n        <Button Content=\"Add\"\n                Command=\"{x:Bind ViewModel.AddCommand}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"Values\"\n                   Style=\"{ThemeResource TitleTextBlockStyle}\"\n                   Grid.Row=\"1\" />\n        <ListView ItemsSource=\"{x:Bind ViewModel.ValuesSource}\"\n                  ItemTemplate=\"{StaticResource valueHolderDataTemplate}\"\n                  Grid.Row=\"2\" />\n        <TextBlock Text=\"Filtered Values\"\n                   Style=\"{ThemeResource TitleTextBlockStyle}\"\n                   Grid.Row=\"1\"\n                   Grid.Column=\"1\" />\n        <ListView ItemsSource=\"{x:Bind ViewModel.Values}\"\n                  ItemTemplate=\"{StaticResource valueHolderDataTemplate}\"\n                  Grid.Row=\"2\"\n                  Grid.Column=\"1\" />\n    </Grid>\n</Page>\n\n\n\n\n\n\nWhen the Value property is greater than 7, then display the value to the ListView which is the right side.",
            "title": "Collections"
        },
        {
            "location": "/features/Collections/#reactivecollection",
            "text": "ReactiveCollection hnherits ObservableCollection.\nThis class is created from IObservable.\nAnd adds an item when push a value from source IObservable.\nReactiveCollection executes this process using IScheduler. Default scheduler run process on the UI thread.  public class ViewModel\n{\n    public ReactiveCollection<DateTime> Records { get; }\n\n    public ReactiveCommand StartRecordCommand { get; }\n\n    public ViewModel()\n    {\n        StartRecordCommand = new ReactiveCommand();\n        // Create a ReactiveCollection instance from IObservable\n        Records = StartRecordCommand\n            .ToUnit()\n            .Take(1)\n            .Concat(Observable.Defer(() => Observable.Interval(TimeSpan.FromSeconds(1)).ToUnit()))\n            .Select(_ => DateTime.Now)\n            .ToReactiveCollection();\n    }\n}   ToUnit extension method is defined in the Reactive.Bindings.Extensions namespace.\nThis extension method is same as  .Select(_ => Unide.Default) .   Example of UWP platform.  MainPage.xaml.cs  public sealed partial class MainPage : Page\n{\n    public ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}  MainPage.xaml  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <StackPanel Orientation=\"Horizontal\">\n            <Button Content=\"Start\"\n                    Command=\"{x:Bind ViewModel.StartRecordCommand}\"\n                    Margin=\"5\" />\n        </StackPanel>\n        <ListView ItemsSource=\"{x:Bind ViewModel.Records}\"\n                  Grid.Row=\"1\" />\n    </Grid>\n</Page>",
            "title": "ReactiveCollection"
        },
        {
            "location": "/features/Collections/#collection-operations",
            "text": "ReactiveCollection class has XxxxOnScheduler methods. For example, AddOnScheduler, RemoveOnScheduler, ClearOnScheduler, GetOnScheduler, etc...\nThose methods are run on the IScheduler.  Can call from outside of UI thread.  public class ViewModel\n{\n    public ReactiveCollection<DateTime> Records { get; }\n\n    public ReactiveCommand StartRecordCommand { get; }\n\n    public ReactiveCommand ClearCommand { get; }\n\n    public ViewModel()\n    {\n        StartRecordCommand = new ReactiveCommand();\n        // Create a ReactiveCollection instance from IObservable\n        Records = StartRecordCommand\n            .ToUnit()\n            .Take(1)\n            .Concat(Observable.Defer(() => Observable.Interval(TimeSpan.FromSeconds(1)).ToUnit()))\n            .Select(_ => DateTime.Now)\n            .ToReactiveCollection();\n\n        ClearCommand = new ReactiveCommand();\n        ClearCommand.ObserveOn(TaskPoolScheduler.Default) // run on the another thread\n            .Subscribe(_ => Records.ClearOnScheduler());\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <StackPanel Orientation=\"Horizontal\">\n            <Button Content=\"Start\"\n                    Command=\"{x:Bind ViewModel.StartRecordCommand}\"\n                    Margin=\"5\" />\n            <Button Content=\"Clear\"\n                    Command=\"{x:Bind ViewModel.ClearCommand}\"\n                    Margin=\"5\" />\n        </StackPanel>\n        <ListView ItemsSource=\"{x:Bind ViewModel.Records}\"\n                  Grid.Row=\"1\" />\n    </Grid>\n</Page>   When ReactiveCollection class was called Dispose method, then unsubscribe the source IObservable instance.",
            "title": "Collection operations"
        },
        {
            "location": "/features/Collections/#readonlyreactivecollection",
            "text": "ReadOnlyReactiveCollection class provides one-way synchronization from ObservableCollection. Can set a converting logic, and dispatch CollectionChanged event raise on the IScheduler. Default IScheduler dispatch to the UI thread.  At first, exist a POCO classes.  public class BindableBase : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    protected void RaisePropertyChanged([CallerMemberName]string propertyName = null) =>\n        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n\n    protected void SetProperty<T>(ref T field, T value, [CallerMemberName]string propertyName = null)\n    {\n        if (EqualityComparer<T>.Default.Equals(field, value))\n        {\n            return;\n        }\n\n        field = value;\n        RaisePropertyChanged(propertyName);\n    }\n}\n\npublic class TimerObject : BindableBase, IDisposable\n{\n    private IDisposable Disposable { get; }\n\n    private long _count;\n    public long Count\n    {\n        get { return _count; }\n        private set { SetProperty(ref _count, value); }\n    }\n\n    public TimerObject()\n    {\n        Disposable = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Subscribe(_ => Count++);\n    }\n\n    public void Dispose()\n    {\n        Disposable.Dispose();\n    }\n}  This is a simple class that counts up the Count property per second.  Wrap the class to ViewModel layer using ReactiveProperty.  public class TimerObjectViewModel : IDisposable\n{\n    public TimerObject Model { get; }\n\n    public ReadOnlyReactiveProperty<string> CountMessage { get; }\n\n    public TimerObjectViewModel(TimerObject timerObject)\n    {\n        Model = timerObject;\n        CountMessage = Model.ObserveProperty(x => x.Count)\n            .Select(x => $\"Count value is {x}.\")\n            .ToReadOnlyReactiveProperty();\n    }\n\n    public void Dispose()\n    {\n        Model.Dispose();\n    }\n}  Manage TimerObject instances using the ObservableCollection.\nWe should provide TimerObjectViewModel instances to View layer, can use ReadOnlyReactiveCollection class.\nReadOnlyReactiveCollection instance is created using ToReadOnlyReactiveCollection extension method.   public class ViewModel\n{\n    // TimerObject collection\n    private ReactiveCollection<TimerObject> ModelCollection { get; }\n    // TimerObjectViewModel collection\n    public ReadOnlyReactiveCollection<TimerObjectViewModel> ViewModelCollection { get; }\n\n    public ReactiveCommand AddCommand { get; }\n\n    public ReactiveCommand<TimerObjectViewModel> RemoveCommand { get; }\n\n    public ViewModel()\n    {\n        AddCommand = new ReactiveCommand();\n        ModelCollection = AddCommand\n            .Select(_ => new TimerObject())\n            .ToReactiveCollection();\n        // Create a ReadOnlyReactiveCollection instance using the converting logic.\n        ViewModelCollection = ModelCollection\n            .ToReadOnlyReactiveCollection(x => new TimerObjectViewModel(x));\n\n        RemoveCommand = new ReactiveCommand<TimerObjectViewModel>()\n            .WithSubscribe(x => ModelCollection.Remove(x.Model));\n    }\n}  Test view is below.  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      xmlns:viewModels=\"using:ViewModels\"\n      mc:Ignorable=\"d\"\n      x:Name=\"root\">\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <Button Content=\"Add\"\n                Command=\"{x:Bind ViewModel.AddCommand}\"\n                Margin=\"5\" />\n        <ListView ItemsSource=\"{x:Bind ViewModel.ViewModelCollection}\"\n                  Grid.Row=\"1\">\n            <ListView.ItemTemplate>\n                <DataTemplate x:DataType=\"viewModels:TimerObjectViewModel\">\n                    <Grid>\n                        <Grid.ColumnDefinitions>\n                            <ColumnDefinition Width=\"Auto\" />\n                            <ColumnDefinition />\n                        </Grid.ColumnDefinitions>\n                        <Button Content=\"Remove\"\n                                Command=\"{Binding ViewModel.RemoveCommand, ElementName=root}\"\n                                CommandParameter=\"{x:Bind}\"\n                                Margin=\"5\" />\n                        <TextBlock Text=\"{x:Bind CountMessage.Value, Mode=OneWay}\"\n                                   VerticalAlignment=\"Center\"\n                                   Style=\"{ThemeResource BodyTextBlockStyle}\"\n                                   Grid.Column=\"1\" />\n                    </Grid>\n                </DataTemplate>\n            </ListView.ItemTemplate>\n        </ListView>\n    </Grid>\n</Page>   When the instance was removed in the ReadOnlyReactiveCollection, then the Dispose method is called. If don't need this behavior, then set false the ToReadOnlyReactiveCollection's disposeElement argument.  ViewModelCollection = ModelCollection\n    .ToReadOnlyReactiveCollection(x => new TimerObjectViewModel(x), disposeElement: false);",
            "title": "ReadOnlyReactiveCollection"
        },
        {
            "location": "/features/Collections/#create-from-iobservable",
            "text": "ReadOnlyReactiveCollection can create from IObservable, it is same as the ReactiveCollection. But, ReadOnlyReactiveCollection doesn't have collection operation methods.\nToReadOnlyReactiveCollection extension method has a onReset argument which type is IObservable<Unity>.\nWhen this argument raises value, then the collection is cleared.  public class ViewModel\n{\n    public ReadOnlyReactiveCollection<string> Messages { get; }\n\n    public ReactiveCommand ResetCommand { get; }\n\n    public ViewModel()\n    {\n        ResetCommand = new ReactiveCommand();\n        Messages = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Select(_ => DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\"))\n            .ToReadOnlyReactiveCollection(ResetCommand.ToUnit());\n    }\n}  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <Button Content=\"Reset\"\n                Command=\"{x:Bind ViewModel.ResetCommand}\"\n                Margin=\"5\" />\n        <ListView ItemsSource=\"{x:Bind ViewModel.Messages}\"\n                  Grid.Row=\"1\" />\n    </Grid>\n</Page>  When the ResetCommand execute, then clear the Messages.",
            "title": "Create from IObservable"
        },
        {
            "location": "/features/Collections/#ifilteredreadonlyobservablecollection",
            "text": "This provides collection which filter realtime from ObservableCollection.\nIFilteredReadOnlyObservableCollection watch the PropertyChanged event of source collection item and the CollectionChanged event.  public class ValueHolder : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    public int Id { get; set; }\n\n    private int _value;\n    public int Value\n    {\n        get => _value;\n        set\n        {\n            _value = value;\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Value)));\n        }\n    }\n\n    public ValueHolder()\n    {\n        var r = new Random();\n        Observable.Interval(TimeSpan.FromSeconds(1))\n            .ObserveOnUIDispatcher()\n            .Subscribe(_ => Value = r.Next(10));\n    }\n}\n\npublic class ViewModel\n{\n    public ReactiveCollection<ValueHolder> ValuesSource { get; }\n\n    public IFilteredReadOnlyObservableCollection<ValueHolder> Values { get; }\n\n    public ReactiveCommand AddCommand { get; }\n\n    public ViewModel()\n    {\n        AddCommand = new ReactiveCommand();\n        ValuesSource = AddCommand\n            .Select(_ => new ValueHolder { Id = ValuesSource.Count })\n            .ToReactiveCollection();\n        Values = ValuesSource.ToFilteredReadOnlyObservableCollection(\n            x => x.Value > 7);\n    }\n}   ObserveOnUIDispatcher extension method switch to the UI thread from the current thread.   <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      xmlns:viewModels=\"using:ViewModels\"\n      mc:Ignorable=\"d\"\n      x:Name=\"root\">\n    <Page.Resources>\n        <DataTemplate x:Key=\"valueHolderDataTemplate\"\n                      x:DataType=\"viewModels:ValueHolder\">\n            <TextBlock>\n                <Run Text=\"Id: \" />\n                <Run Text=\"{x:Bind Id}\" />\n                <Run Text=\", Value: \" />\n                <Run Text=\"{x:Bind Value, Mode=OneWay}\" />\n            </TextBlock>\n        </DataTemplate>\n    </Page.Resources>\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition Height=\"Auto\" />\n            <RowDefinition />\n        </Grid.RowDefinitions>\n        <Grid.ColumnDefinitions>\n            <ColumnDefinition />\n            <ColumnDefinition />\n        </Grid.ColumnDefinitions>\n        <Button Content=\"Add\"\n                Command=\"{x:Bind ViewModel.AddCommand}\"\n                Margin=\"5\" />\n        <TextBlock Text=\"Values\"\n                   Style=\"{ThemeResource TitleTextBlockStyle}\"\n                   Grid.Row=\"1\" />\n        <ListView ItemsSource=\"{x:Bind ViewModel.ValuesSource}\"\n                  ItemTemplate=\"{StaticResource valueHolderDataTemplate}\"\n                  Grid.Row=\"2\" />\n        <TextBlock Text=\"Filtered Values\"\n                   Style=\"{ThemeResource TitleTextBlockStyle}\"\n                   Grid.Row=\"1\"\n                   Grid.Column=\"1\" />\n        <ListView ItemsSource=\"{x:Bind ViewModel.Values}\"\n                  ItemTemplate=\"{StaticResource valueHolderDataTemplate}\"\n                  Grid.Row=\"2\"\n                  Grid.Column=\"1\" />\n    </Grid>\n</Page>   When the Value property is greater than 7, then display the value to the ListView which is the right side.",
            "title": "IFilteredReadOnlyObservableCollection"
        },
        {
            "location": "/features/Work-together-with-plane-model-layer-objects/",
            "text": "The classes of this library can work together with POCO classes.\n\n\nConnect to classes that implement INotifyPropertyChanged\n\n\nReactiveProperty provides many features that synchronize to POCO class instance.\n\n\nOne-way synchronization\n\n\nToObserveProperty extension method of INotifyPropertyChanged interface convert INotifyPropertyChanged to IObservable<T>.\nIObservable can convert to ReactiveProperty. It means that can be one-way synchronization to ReactiveProperty from INotifyPropertyChanged.\n\n\nFor example, below class is.\n\n\npublic class BindableBase : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    protected void RaisePropertyChanged([CallerMemberName]string propertyName = null) =>\n        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n\n    protected void SetProperty<T>(ref T field, T value, [CallerMemberName]string propertyName = null)\n    {\n        if (Comparer<T>.Default.Compare(field, value) == 0)\n        {\n            return;\n        }\n\n        field = value;\n        RaisePropertyChanged(propertyName);\n    }\n}\n\npublic class Person : BindableBase\n{\n    private string _name;\n    public string Name\n    {\n        get { return _name; }\n        set { SetProperty(ref _name, value); }\n    }\n\n    private int _age;\n    public int Age\n    {\n        get { return _age; }\n        set { SetProperty(ref _age, value); }\n    }\n}\n\n\n\n\nOne-way synchronization is the following code.\n\n\n// using Reactive.Bindings.Extensions;\npublic class ViewModel\n{\n    private Person Person { get; } = new Person();\n\n    public ReadOnlyReactiveProperty<string> Name { get; }\n\n    public ReactiveCommand UpdatePersonCommand { get; }\n\n    public ViewModel()\n    {\n        Name = Person\n            // Convert the Name PropertyChanged event to IObservable<string>\n            .ObserveProperty(x => x.Name)\n            // Convert to ReadOnlyReactiveProperty<string>\n            .ToReadOnlyReactiveProperty();\n\n        UpdatePersonCommand = new ReactiveCommand()\n            .WithSubscribe(() =>\n            {\n                // Update the name property.\n                Person.Name = \"Tanaka\";\n            });\n    }\n}\n\n\n\n\nTwo-way synchronization\n\n\nToReactivePropertyAsSynchronized extension method provides two-way synchronization.\n\n\n// using Reactive.Bindings.Extensions;\npublic class ViewModel\n{\n    public Person Person { get; } = new Person();\n\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = Person.ToReactivePropertyAsSynchronized(x => x.Name);\n    }\n}\n\n\n\n\nUWP platfrom example is below.\n\n\nMainPage.xaml.cs\n\n\npublic sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}\n\n\n\n\nMainPage.xaml\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"ReactiveProperty\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5,0\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"Person.Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5,0\" />\n        <TextBox Text=\"{x:Bind ViewModel.Person.Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n    </StackPanel>\n</Page>\n\n\n\n\n\n\nToSynchronizedReactiveProperty extension method can add convert logic and convert-back logic.\n\n\npublic class ViewModel\n{\n    public Person Person { get; } = new Person();\n\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = Person.ToReactivePropertyAsSynchronized(x => x.Name,\n            convert: x => string.IsNullOrWhiteSpace(x) ? \"\" : $\"{x}-san\",\n            convertBack: x => Regex.Replace(x, \"-san$\", \"\"));\n    }\n}\n\n\n\n\n\n\nWhen an ignoreValidationErrorValue argument set to true, then stop the synchronization if validation error occurred.\n\n\npublic class ViewModel\n{\n    public Person Person { get; } = new Person();\n\n    [StringLength(10)]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = Person.ToReactivePropertyAsSynchronized(x => x.Name,\n            convert: x => string.IsNullOrWhiteSpace(x) ? \"\" : $\"{x}-san\",\n            convertBack: x => Regex.Replace(x, \"-san$\", \"\"),\n            ignoreValidationErrorValue: true)  // activate this behavior\n            .SetValidateAttribute(() => Name); // set validation logic\n    }\n}\n\n\n\n\n\n\nOne-time synchronization\n\n\nThe FromObject method creates a ReactiveProperty instance from POCO.\nThis method set Value property from POCO when the ReactiveProperty instance created.\n\n\nusing Reactive.Bindings;\nusing System;\n\nnamespace ReactivePropertyEduApp\n{\n    class Sample\n    {\n        public string Property1 { get; set; }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sample = new Sample { Property1 = \"xxx\" };\n\n            var rp = ReactiveProperty.FromObject(sample, x => x.Property1);\n            Console.WriteLine(rp.Value); // -> xxx\n            sample.Property1 = \"updated\";\n            Console.WriteLine(rp.Value); // -> xxx\n        }\n    }\n}",
            "title": "Work together with plane model layer objects"
        },
        {
            "location": "/features/Work-together-with-plane-model-layer-objects/#connect-to-classes-that-implement-inotifypropertychanged",
            "text": "ReactiveProperty provides many features that synchronize to POCO class instance.",
            "title": "Connect to classes that implement INotifyPropertyChanged"
        },
        {
            "location": "/features/Work-together-with-plane-model-layer-objects/#one-way-synchronization",
            "text": "ToObserveProperty extension method of INotifyPropertyChanged interface convert INotifyPropertyChanged to IObservable<T>.\nIObservable can convert to ReactiveProperty. It means that can be one-way synchronization to ReactiveProperty from INotifyPropertyChanged.  For example, below class is.  public class BindableBase : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    protected void RaisePropertyChanged([CallerMemberName]string propertyName = null) =>\n        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n\n    protected void SetProperty<T>(ref T field, T value, [CallerMemberName]string propertyName = null)\n    {\n        if (Comparer<T>.Default.Compare(field, value) == 0)\n        {\n            return;\n        }\n\n        field = value;\n        RaisePropertyChanged(propertyName);\n    }\n}\n\npublic class Person : BindableBase\n{\n    private string _name;\n    public string Name\n    {\n        get { return _name; }\n        set { SetProperty(ref _name, value); }\n    }\n\n    private int _age;\n    public int Age\n    {\n        get { return _age; }\n        set { SetProperty(ref _age, value); }\n    }\n}  One-way synchronization is the following code.  // using Reactive.Bindings.Extensions;\npublic class ViewModel\n{\n    private Person Person { get; } = new Person();\n\n    public ReadOnlyReactiveProperty<string> Name { get; }\n\n    public ReactiveCommand UpdatePersonCommand { get; }\n\n    public ViewModel()\n    {\n        Name = Person\n            // Convert the Name PropertyChanged event to IObservable<string>\n            .ObserveProperty(x => x.Name)\n            // Convert to ReadOnlyReactiveProperty<string>\n            .ToReadOnlyReactiveProperty();\n\n        UpdatePersonCommand = new ReactiveCommand()\n            .WithSubscribe(() =>\n            {\n                // Update the name property.\n                Person.Name = \"Tanaka\";\n            });\n    }\n}",
            "title": "One-way synchronization"
        },
        {
            "location": "/features/Work-together-with-plane-model-layer-objects/#two-way-synchronization",
            "text": "ToReactivePropertyAsSynchronized extension method provides two-way synchronization.  // using Reactive.Bindings.Extensions;\npublic class ViewModel\n{\n    public Person Person { get; } = new Person();\n\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = Person.ToReactivePropertyAsSynchronized(x => x.Name);\n    }\n}  UWP platfrom example is below.  MainPage.xaml.cs  public sealed partial class MainPage : Page\n{\n    private ViewModel ViewModel { get; } = new ViewModel();\n    public MainPage()\n    {\n        this.InitializeComponent();\n    }\n}  MainPage.xaml  <Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock Text=\"ReactiveProperty\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5,0\" />\n        <TextBox Text=\"{x:Bind ViewModel.Name.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n        <TextBlock Text=\"Person.Name\"\n                   Style=\"{ThemeResource CaptionTextBlockStyle}\"\n                   Margin=\"5,0\" />\n        <TextBox Text=\"{x:Bind ViewModel.Person.Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                 Margin=\"5\" />\n    </StackPanel>\n</Page>   ToSynchronizedReactiveProperty extension method can add convert logic and convert-back logic.  public class ViewModel\n{\n    public Person Person { get; } = new Person();\n\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = Person.ToReactivePropertyAsSynchronized(x => x.Name,\n            convert: x => string.IsNullOrWhiteSpace(x) ? \"\" : $\"{x}-san\",\n            convertBack: x => Regex.Replace(x, \"-san$\", \"\"));\n    }\n}   When an ignoreValidationErrorValue argument set to true, then stop the synchronization if validation error occurred.  public class ViewModel\n{\n    public Person Person { get; } = new Person();\n\n    [StringLength(10)]\n    public ReactiveProperty<string> Name { get; }\n\n    public ViewModel()\n    {\n        Name = Person.ToReactivePropertyAsSynchronized(x => x.Name,\n            convert: x => string.IsNullOrWhiteSpace(x) ? \"\" : $\"{x}-san\",\n            convertBack: x => Regex.Replace(x, \"-san$\", \"\"),\n            ignoreValidationErrorValue: true)  // activate this behavior\n            .SetValidateAttribute(() => Name); // set validation logic\n    }\n}",
            "title": "Two-way synchronization"
        },
        {
            "location": "/features/Work-together-with-plane-model-layer-objects/#one-time-synchronization",
            "text": "The FromObject method creates a ReactiveProperty instance from POCO.\nThis method set Value property from POCO when the ReactiveProperty instance created.  using Reactive.Bindings;\nusing System;\n\nnamespace ReactivePropertyEduApp\n{\n    class Sample\n    {\n        public string Property1 { get; set; }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sample = new Sample { Property1 = \"xxx\" };\n\n            var rp = ReactiveProperty.FromObject(sample, x => x.Property1);\n            Console.WriteLine(rp.Value); // -> xxx\n            sample.Property1 = \"updated\";\n            Console.WriteLine(rp.Value); // -> xxx\n        }\n    }\n}",
            "title": "One-time synchronization"
        },
        {
            "location": "/features/Notifiers/",
            "text": "Reactive.Bindings.Notifiers namespace provides many useful classes which implements IObservable interface.\n\n\nBooleanNotifier\n\n\nBooleanNotifier class implements IObservable<bool> interface.\nAnd has some methods and property.\n\n\n\n\nTurnOn method\n\n\nChange state to true.\n\n\n\n\n\n\nTurnOff method\n\n\nChange state to false.\n\n\n\n\n\n\nSwitchValue method\n\n\nSwitch state.\n\n\n\n\n\n\nValue property\n\n\nSet state\n\n\n\n\n\n\n\n\nThe initial state can be set the constructor. The default value is false.\n\n\nvar n = new BooleanNotifier();\nn.Subscribe(x => Debug.WriteLine(x));\n\nn.TurnOn(); // true\nn.TurnOff(); // false\nn.Value = true; // true\nn.Value = false; // false\n\n\n\n\nIt can use to source of ReactiveCommand.\n\n\nCountNotifier\n\n\nCountNotifier class implements IObservable<CountChangedStates> interface. It provides increment and decrement features, and raise a CountChangedStates value when the state changed.\n\n\nCountChangedStates enum is defined as below.\n\n\n/// <summary>Event kind of CountNotifier.</summary>\npublic enum CountChangedStatus\n{\n    /// <summary>Count incremented.</summary>\n    Increment,\n    /// <summary>Count decremented.</summary>\n    Decrement,\n    /// <summary>Count is zero.</summary>\n    Empty,\n    /// <summary>Count arrived max.</summary>\n    Max\n}\n\n\n\n\nCountNotifier's max value can be set from constructor argument.\n\n\nHow to use.\n\n\nvar c = new CountNotifier(); // default max value is int.MaxValue\n// output status.\nc.Subscribe(x => Debug.WriteLine(x));\n// output current value.\nc.Select(_ => c.Count).Subscribe(x => Debug.WriteLine(x));\n// increment\nvar d = c.Increment(10);\n// revert increment\nd.Dispose();\n// increment and decrement\nc.Increment(10);\nc.Decrement(5);\n// output current value.\nDebug.WriteLine(c.Count);\n\n\n\n\nOutput is below.\n\n\nIncrement\n10\nDecrement\n0\nEmpty\n0\nIncrement\n10\nDecrement\n5\n5\n\n\n\n\nScheduledNotifier\n\n\nThis class provides it that raise the value on the scheduler. Default scheduler is \nScheduler.Immediate\n. Set the scheduler using constructor argument.\n\n\nvar n = new ScheduledNotifier<string>();\nn.Subscribe(x => Debug.WriteLine(x));\n// output the value immediately\nn.Report(\"Hello world\");\n// output the value after 2 seconds.\nn.Report(\"After 2 seconds.\", TimeSpan.FromSeconds(2));\n\n\n\n\nBusyNotifier\n\n\nThis class implements IObservable<bool> interface.\nIt raises \ntrue\n during running the process, raises 'false' when all processes end.\n\n\nThe StartProcess method returns an IDisposable instance. When finishing the process, then call the Dispose method.\n\n\nusing Reactive.Bindings.Notifiers;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace ReactivePropertyEduApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MainAsync(args).Wait();\n        }\n\n        static async Task MainAsync(string[] args)\n        {\n            var b = new BusyNotifier();\n            b.Subscribe(x => Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: OnNext: {x}\"));\n\n            await Task.WhenAll(\n                Task.Run(async () =>\n                {\n                    using (b.ProcessStart())\n                    {\n                        Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: Process1 started.\");\n                        await Task.Delay(TimeSpan.FromSeconds(1));\n                        Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: Process1 finished.\");\n                    }\n                }),\n                Task.Run(async () =>\n                {\n                    using (b.ProcessStart())\n                    {\n                        Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: Process2 started.\");\n                        await Task.Delay(TimeSpan.FromSeconds(2));\n                        Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: Process2 finished.\");\n                    }\n                }));\n        }\n    }\n}\n\n\n\n\nOutput is below.\n\n\n15:07:45: OnNext: False\n15:07:45: OnNext: True\n15:07:45: Process1 started.\n15:07:45: Process2 started.\n15:07:46: Process1 finished.\n15:07:47: Process2 finished.\n15:07:47: OnNext: False\n\n\n\n\nMessageBroker\n\n\nI suggest new notifier called MessageBroker , in-memory pubsub. This is Rx and async friendly EventAggregator or MessageBus or etc. We can use this for messenger pattern.\nIf reviewer accept this code, please add to all platforms.\n\n\nusing Reactive.Bindings.Notifiers;\nusing System;\nusing System.Reactive.Linq;\nusing System.Threading.Tasks;\n\npublic class MyClass\n{\n    public int MyProperty { get; set; }\n\n    public override string ToString()\n    {\n        return \"MP:\" + MyProperty;\n    }\n}\nclass Program\n{\n    static void RunMessageBroker()\n    {\n        // global scope pub-sub messaging\n        MessageBroker.Default.Subscribe<MyClass>(x =>\n        {\n            Console.WriteLine(\"A:\" + x);\n        });\n\n        var d = MessageBroker.Default.Subscribe<MyClass>(x =>\n        {\n            Console.WriteLine(\"B:\" + x);\n        });\n\n        // support convert to IObservable<T>\n        MessageBroker.Default.ToObservable<MyClass>().Subscribe(x =>\n        {\n            Console.WriteLine(\"C:\" + x);\n        });\n\n        MessageBroker.Default.Publish(new MyClass { MyProperty = 100 });\n        MessageBroker.Default.Publish(new MyClass { MyProperty = 200 });\n        MessageBroker.Default.Publish(new MyClass { MyProperty = 300 });\n\n        d.Dispose(); // unsubscribe\n        MessageBroker.Default.Publish(new MyClass { MyProperty = 400 });\n    }\n\n    static async Task RunAsyncMessageBroker()\n    {\n        // asynchronous message pub-sub\n        AsyncMessageBroker.Default.Subscribe<MyClass>(async x =>\n        {\n            Console.WriteLine(\"A:\" + x);\n            await Task.Delay(TimeSpan.FromSeconds(1));\n        });\n\n        var d = AsyncMessageBroker.Default.Subscribe<MyClass>(async x =>\n        {\n            Console.WriteLine(\"B:\" + x);\n            await Task.Delay(TimeSpan.FromSeconds(2));\n        });\n\n        // await all subscriber complete\n        await AsyncMessageBroker.Default.PublishAsync(new MyClass { MyProperty = 100 });\n        await AsyncMessageBroker.Default.PublishAsync(new MyClass { MyProperty = 200 });\n        await AsyncMessageBroker.Default.PublishAsync(new MyClass { MyProperty = 300 });\n\n        d.Dispose(); // unsubscribe\n        await AsyncMessageBroker.Default.PublishAsync(new MyClass { MyProperty = 400 });\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"MessageBroker\");\n        RunMessageBroker();\n\n        Console.WriteLine(\"AsyncMessageBroker\");\n        RunAsyncMessageBroker().Wait();\n    }\n}\n\n\n\n\nMessenger pattern's multi thread dispatch can handle easily by Rx.\n\n\nMessageBroker.Default.ToObservable<MyClass>()\n    .ObserveOn(Dispatcher) // Rx Magic!\n    .Subscribe(x =>\n    {\n        Console.WriteLine(x);\n    });",
            "title": "Useful classes which implement IObservable"
        },
        {
            "location": "/features/Notifiers/#booleannotifier",
            "text": "BooleanNotifier class implements IObservable<bool> interface.\nAnd has some methods and property.   TurnOn method  Change state to true.    TurnOff method  Change state to false.    SwitchValue method  Switch state.    Value property  Set state     The initial state can be set the constructor. The default value is false.  var n = new BooleanNotifier();\nn.Subscribe(x => Debug.WriteLine(x));\n\nn.TurnOn(); // true\nn.TurnOff(); // false\nn.Value = true; // true\nn.Value = false; // false  It can use to source of ReactiveCommand.",
            "title": "BooleanNotifier"
        },
        {
            "location": "/features/Notifiers/#countnotifier",
            "text": "CountNotifier class implements IObservable<CountChangedStates> interface. It provides increment and decrement features, and raise a CountChangedStates value when the state changed.  CountChangedStates enum is defined as below.  /// <summary>Event kind of CountNotifier.</summary>\npublic enum CountChangedStatus\n{\n    /// <summary>Count incremented.</summary>\n    Increment,\n    /// <summary>Count decremented.</summary>\n    Decrement,\n    /// <summary>Count is zero.</summary>\n    Empty,\n    /// <summary>Count arrived max.</summary>\n    Max\n}  CountNotifier's max value can be set from constructor argument.  How to use.  var c = new CountNotifier(); // default max value is int.MaxValue\n// output status.\nc.Subscribe(x => Debug.WriteLine(x));\n// output current value.\nc.Select(_ => c.Count).Subscribe(x => Debug.WriteLine(x));\n// increment\nvar d = c.Increment(10);\n// revert increment\nd.Dispose();\n// increment and decrement\nc.Increment(10);\nc.Decrement(5);\n// output current value.\nDebug.WriteLine(c.Count);  Output is below.  Increment\n10\nDecrement\n0\nEmpty\n0\nIncrement\n10\nDecrement\n5\n5",
            "title": "CountNotifier"
        },
        {
            "location": "/features/Notifiers/#schedulednotifier",
            "text": "This class provides it that raise the value on the scheduler. Default scheduler is  Scheduler.Immediate . Set the scheduler using constructor argument.  var n = new ScheduledNotifier<string>();\nn.Subscribe(x => Debug.WriteLine(x));\n// output the value immediately\nn.Report(\"Hello world\");\n// output the value after 2 seconds.\nn.Report(\"After 2 seconds.\", TimeSpan.FromSeconds(2));",
            "title": "ScheduledNotifier"
        },
        {
            "location": "/features/Notifiers/#busynotifier",
            "text": "This class implements IObservable<bool> interface.\nIt raises  true  during running the process, raises 'false' when all processes end.  The StartProcess method returns an IDisposable instance. When finishing the process, then call the Dispose method.  using Reactive.Bindings.Notifiers;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace ReactivePropertyEduApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MainAsync(args).Wait();\n        }\n\n        static async Task MainAsync(string[] args)\n        {\n            var b = new BusyNotifier();\n            b.Subscribe(x => Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: OnNext: {x}\"));\n\n            await Task.WhenAll(\n                Task.Run(async () =>\n                {\n                    using (b.ProcessStart())\n                    {\n                        Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: Process1 started.\");\n                        await Task.Delay(TimeSpan.FromSeconds(1));\n                        Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: Process1 finished.\");\n                    }\n                }),\n                Task.Run(async () =>\n                {\n                    using (b.ProcessStart())\n                    {\n                        Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: Process2 started.\");\n                        await Task.Delay(TimeSpan.FromSeconds(2));\n                        Console.WriteLine($\"{DateTime.Now.ToString(\"HH:mm:ss\")}: Process2 finished.\");\n                    }\n                }));\n        }\n    }\n}  Output is below.  15:07:45: OnNext: False\n15:07:45: OnNext: True\n15:07:45: Process1 started.\n15:07:45: Process2 started.\n15:07:46: Process1 finished.\n15:07:47: Process2 finished.\n15:07:47: OnNext: False",
            "title": "BusyNotifier"
        },
        {
            "location": "/features/Notifiers/#messagebroker",
            "text": "I suggest new notifier called MessageBroker , in-memory pubsub. This is Rx and async friendly EventAggregator or MessageBus or etc. We can use this for messenger pattern.\nIf reviewer accept this code, please add to all platforms.  using Reactive.Bindings.Notifiers;\nusing System;\nusing System.Reactive.Linq;\nusing System.Threading.Tasks;\n\npublic class MyClass\n{\n    public int MyProperty { get; set; }\n\n    public override string ToString()\n    {\n        return \"MP:\" + MyProperty;\n    }\n}\nclass Program\n{\n    static void RunMessageBroker()\n    {\n        // global scope pub-sub messaging\n        MessageBroker.Default.Subscribe<MyClass>(x =>\n        {\n            Console.WriteLine(\"A:\" + x);\n        });\n\n        var d = MessageBroker.Default.Subscribe<MyClass>(x =>\n        {\n            Console.WriteLine(\"B:\" + x);\n        });\n\n        // support convert to IObservable<T>\n        MessageBroker.Default.ToObservable<MyClass>().Subscribe(x =>\n        {\n            Console.WriteLine(\"C:\" + x);\n        });\n\n        MessageBroker.Default.Publish(new MyClass { MyProperty = 100 });\n        MessageBroker.Default.Publish(new MyClass { MyProperty = 200 });\n        MessageBroker.Default.Publish(new MyClass { MyProperty = 300 });\n\n        d.Dispose(); // unsubscribe\n        MessageBroker.Default.Publish(new MyClass { MyProperty = 400 });\n    }\n\n    static async Task RunAsyncMessageBroker()\n    {\n        // asynchronous message pub-sub\n        AsyncMessageBroker.Default.Subscribe<MyClass>(async x =>\n        {\n            Console.WriteLine(\"A:\" + x);\n            await Task.Delay(TimeSpan.FromSeconds(1));\n        });\n\n        var d = AsyncMessageBroker.Default.Subscribe<MyClass>(async x =>\n        {\n            Console.WriteLine(\"B:\" + x);\n            await Task.Delay(TimeSpan.FromSeconds(2));\n        });\n\n        // await all subscriber complete\n        await AsyncMessageBroker.Default.PublishAsync(new MyClass { MyProperty = 100 });\n        await AsyncMessageBroker.Default.PublishAsync(new MyClass { MyProperty = 200 });\n        await AsyncMessageBroker.Default.PublishAsync(new MyClass { MyProperty = 300 });\n\n        d.Dispose(); // unsubscribe\n        await AsyncMessageBroker.Default.PublishAsync(new MyClass { MyProperty = 400 });\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"MessageBroker\");\n        RunMessageBroker();\n\n        Console.WriteLine(\"AsyncMessageBroker\");\n        RunAsyncMessageBroker().Wait();\n    }\n}  Messenger pattern's multi thread dispatch can handle easily by Rx.  MessageBroker.Default.ToObservable<MyClass>()\n    .ObserveOn(Dispatcher) // Rx Magic!\n    .Subscribe(x =>\n    {\n        Console.WriteLine(x);\n    });",
            "title": "MessageBroker"
        },
        {
            "location": "/features/Extension-methods/",
            "text": "Reactive.Bindings.Extensions namespace provides useful extension methods.\n\n\nAddTo\n\n\nThis is a most usefulest extension method in this namespace.\nCollect to IDisposable instances in the method chain.\n\n\nIn the case which doesn't use this, two statements between instance creation and adding an IDisposable instance.\n\n\n// init\nvar d = new CompositeDisposable();\n\nName = model.ObserveProperty(x => x.Name)\n    .ToReadOnlyReactiveProperty();\nd.Add(Name);\n\nAge = model.ObserveProperty(x => x.Age)\n    .ToReadOnlyReactiveProperty();\nd.Add(Age);\n\n// dispose all\nd.Dispose();\n\n\n\n\nAddTo extension method's sample code:\n\n\n// init\nvar d = new CompositeDisposable();\n\nName = model.ObserveProperty(x => x.Name)\n    .ToReadOnlyReactiveProperty()\n    .AddTo(d);\n\nAge = model.ObserveProperty(x => x.Age)\n    .ToReadOnlyReactiveProperty()\n    .AddTo(d);\n\n// dispose all\nd.Dispose();\n\n\n\n\nIt's very cool!\n\n\nCatchIgnore\n\n\nThis is that catch exception and return Observable.Empty.\n\n\nsource.CatchIgnore((Exception ex) => { ... error action ... })\n    .Subscribe();\n\n\n\n\nCombineLatestsValuesAreAllXXXX\n\n\nProvides two methods.\n\n\n\n\nCombineLatestValuesAreAllTrue\n\n\nCombineLatestValuesAreAllFalse\n\n\n\n\nThis is just shortcuts, see below.\n\n\n/// <summary>\n/// Lastest values of each sequence are all true.\n/// </summary>\npublic static IObservable<bool> CombineLatestValuesAreAllTrue(\n    this IEnumerable<IObservable<bool>> sources) => \n    sources.CombineLatest(xs => xs.All(x => x));\n\n\n/// <summary>\n/// Lastest values of each sequence are all false.\n/// </summary>\npublic static IObservable<bool> CombineLatestValuesAreAllFalse(\n    this IEnumerable<IObservable<bool>> sources) =>\n    sources.CombineLatest(xs => xs.All(x => !x));\n\n\n\n\nCanExecuteChangedAsObservable\n\n\nThis is a extension method of ICommand interface.\nIt is a shortcut the \nObservable.FromEvent\n.\n\n\n/// <summary>Converts CanExecuteChanged to an observable sequence.</summary>\npublic static IObservable<EventArgs> CanExecuteChangedAsObservable<T>(this T source)\n    where T : ICommand =>\n    Observable.FromEvent<EventHandler, EventArgs>(\n        h => (sender, e) => h(e),\n        h => source.CanExecuteChanged += h,\n        h => source.CanExecuteChanged -= h);\n\n\n\n\nINotifyCollectionChanged extension methods\n\n\nConvert CollectionChanged event to IObservable.\n\n\n/// <summary>Observe CollectionChanged:Remove and take single item.</summary>\npublic static IObservable<T> ObserveRemoveChanged<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Remove)\n        .Select(e => (T)e.OldItems[0]);\n\n/// <summary>Observe CollectionChanged:Remove.</summary>\npublic static IObservable<T[]> ObserveRemoveChangedItems<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Remove)\n        .Select(e => e.OldItems.Cast<T>().ToArray());\n\n/// <summary>Observe CollectionChanged:Move and take single item.</summary>\npublic static IObservable<OldNewPair<T>> ObserveMoveChanged<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Move)\n        .Select(e => new OldNewPair<T>((T)e.OldItems[0], (T)e.NewItems[0]));\n\n/// <summary>Observe CollectionChanged:Move.</summary>\npublic static IObservable<OldNewPair<T[]>> ObserveMoveChangedItems<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Move)\n        .Select(e => new OldNewPair<T[]>(e.OldItems.Cast<T>().ToArray(), e.NewItems.Cast<T>().ToArray()));\n\n/// <summary>Observe CollectionChanged:Replace and take single item.</summary>\npublic static IObservable<OldNewPair<T>> ObserveReplaceChanged<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Replace)\n        .Select(e => new OldNewPair<T>((T)e.OldItems[0], (T)e.NewItems[0]));\n\n/// <summary>Observe CollectionChanged:Replace.</summary>\npublic static IObservable<OldNewPair<T[]>> ObserveReplaceChangedItems<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Replace)\n        .Select(e => new OldNewPair<T[]>(e.OldItems.Cast<T>().ToArray(), e.NewItems.Cast<T>().ToArray()));\n\n/// <summary>Observe CollectionChanged:Reset.</summary>\npublic static IObservable<Unit> ObserveResetChanged<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Reset)\n        .Select(_ => new Unit());\n\n\n\n\nObservableCollection extension methods\n\n\nIt is typesafe version INotifyPropertyChanged extension methods.\n\n\n/// <summary>Observe CollectionChanged:Add and take single item.</summary>\npublic static IObservable<T> ObserveAddChanged<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveAddChanged<T>();\n\n/// <summary>Observe CollectionChanged:Add.</summary>\npublic static IObservable<T[]> ObserveAddChangedItems<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveAddChangedItems<T>();\n\n/// <summary>Observe CollectionChanged:Remove and take single item.</summary>\npublic static IObservable<T> ObserveRemoveChanged<T>(this ObservableCollection<T> source) =>\n     ((INotifyCollectionChanged)source).ObserveRemoveChanged<T>();\n\n/// <summary>Observe CollectionChanged:Remove.</summary>\npublic static IObservable<T[]> ObserveRemoveChangedItems<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveRemoveChangedItems<T>();\n\n/// <summary>Observe CollectionChanged:Move and take single item.</summary>\npublic static IObservable<OldNewPair<T>> ObserveMoveChanged<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveMoveChanged<T>();\n\n/// <summary>Observe CollectionChanged:Move.</summary>\npublic static IObservable<OldNewPair<T[]>> ObserveMoveChangedItems<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveMoveChangedItems<T>();\n\n/// <summary>Observe CollectionChanged:Replace and take single item.</summary>\npublic static IObservable<OldNewPair<T>> ObserveReplaceChanged<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveReplaceChanged<T>();\n\n/// <summary>Observe CollectionChanged:Replace.</summary>\npublic static IObservable<OldNewPair<T[]>> ObserveReplaceChangedItems<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveReplaceChangedItems<T>();\n\n/// <summary>Observe CollectionChanged:Reset.</summary>\npublic static IObservable<Unit> ObserveResetChanged<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveResetChanged<T>();\n\n\n\n\nObserve PropertyChanged events of ObservableCollection's items\n\n\nWatch PropertyChanged event of ObservableCollection's items. \nObserveElementProperty extension method can ovserve specific property's PropertyChanged event.\n\n\nusing Reactive.Bindings.Extensions;\nusing System;\nusing System.Collections.ObjectModel;\nusing System.ComponentModel;\n\nnamespace ReactivePropertyEduApp\n{\n    public class Person : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        private string _name;\n        public string Name\n        {\n            get => _name;\n            set\n            {\n                _name = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n            }\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var c = new ObservableCollection<Person>();\n            c.ObserveElementProperty(x => x.Name)\n                .Subscribe(x => Console.WriteLine($\"Subscribe: {x.Instance}, {x.Property.Name}, {x.Value}\"));\n\n            var neuecc = new Person { Name = \"neuecc\" };\n            var xin9le = new Person { Name = \"xin9le\" };\n            var okazuki = new Person { Name = \"okazuki\" };\n\n            Console.WriteLine(\"Add items\");\n            c.Add(neuecc);\n            c.Add(xin9le);\n            c.Add(okazuki);\n\n            Console.WriteLine(\"Change okazuki name to Kazuki Ota\");\n            okazuki.Name = \"Kazuki Ota\";\n\n            Console.WriteLine(\"Remove okazuki from collection\");\n            c.Remove(okazuki);\n\n            Console.WriteLine(\"Change okazuki name to okazuki\");\n            okazuki.Name = \"okazuki\";\n        }\n    }\n}\n\n\n\n\nAdd items\nSubscribe: ReactivePropertyEduApp.Person, Name, neuecc\nSubscribe: ReactivePropertyEduApp.Person, Name, xin9le\nSubscribe: ReactivePropertyEduApp.Person, Name, okazuki\nChange okazuki name to Kazuki Ota\nSubscribe: ReactivePropertyEduApp.Person, Name, Kazuki Ota\nRemove okazuki from collection\nChange okazuki name to okazuki\n\n\n\n\nIf target object's property type is ReactiveProperty, then use the ObserveElementPropertyChanged extension method.\n\n\nusing Reactive.Bindings;\nusing Reactive.Bindings.Extensions;\nusing System;\nusing System.Collections.ObjectModel;\nusing System.ComponentModel;\n\nnamespace ReactivePropertyEduApp\n{\n    public class Person\n    {\n        public ReactiveProperty<string> Name { get; }\n\n        public Person(string name)\n        {\n            Name = new ReactiveProperty<string>(name);\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var c = new ObservableCollection<Person>();\n            c.ObserveElementObservableProperty(x => x.Name)\n                .Subscribe(x => Console.WriteLine($\"Subscribe: {x.Instance}, {x.Property.Name}, {x.Value}\"));\n\n            var neuecc = new Person(\"neuecc\");\n            var xin9le = new Person(\"xin9le\");\n            var okazuki = new Person(\"okazuki\");\n\n            Console.WriteLine(\"Add items\");\n            c.Add(neuecc);\n            c.Add(xin9le);\n            c.Add(okazuki);\n\n            Console.WriteLine(\"Change okazuki name to Kazuki Ota\");\n            okazuki.Name.Value = \"Kazuki Ota\";\n\n            Console.WriteLine(\"Remove okazuki from collection\");\n            c.Remove(okazuki);\n\n            Console.WriteLine(\"Change okazuki name to okazuki\");\n            okazuki.Name.Value = \"okazuki\";\n        }\n    }\n}\n\n\n\n\nAdd items\nSubscribe: ReactivePropertyEduApp.Person, Name, neuecc\nSubscribe: ReactivePropertyEduApp.Person, Name, xin9le\nSubscribe: ReactivePropertyEduApp.Person, Name, okazuki\nChange okazuki name to Kazuki Ota\nSubscribe: ReactivePropertyEduApp.Person, Name, Kazuki Ota\nRemove okazuki from collection\nChange okazuki name to okazuki\n\n\n\n\nINotifyDataErrorInfo extension methods\n\n\nConvert ErrorChanged event to an IObservable<DataErrorsChangedEventArgs>.\nIt is a shortcut of FromEvent method.\n\n\n/// <summary>Converts ErrorsChanged to an observable sequence.</summary>\npublic static IObservable<DataErrorsChangedEventArgs> ErrorsChangedAsObservable<T>(this T subject)\n    where T : INotifyDataErrorInfo =>\n    Observable.FromEvent<EventHandler<DataErrorsChangedEventArgs>, DataErrorsChangedEventArgs>(\n        h => (sender, e) => h(e),\n        h => subject.ErrorsChanged += h,\n        h => subject.ErrorsChanged -= h);\n\n\n\n\nObserveErrorInfo extension method is the version of raise the property value when ErrorChanged event occured.\n\n\nInverse\n\n\nInverse the boolean value of an IObservable<bool> sequence.\n\n\nIObservable<bool> boolSequence = ...;\nIObservable<bool> inversedBoolSequence = boolSequence.Inverse();\n\n\n\n\nIt is a same as below code.\n\n\nIObservable<bool> boolSequence = ...;\nIObservable<bool> inversedBoolSequence = boolSequence.Select(x => !x);",
            "title": "Extension methods"
        },
        {
            "location": "/features/Extension-methods/#addto",
            "text": "This is a most usefulest extension method in this namespace.\nCollect to IDisposable instances in the method chain.  In the case which doesn't use this, two statements between instance creation and adding an IDisposable instance.  // init\nvar d = new CompositeDisposable();\n\nName = model.ObserveProperty(x => x.Name)\n    .ToReadOnlyReactiveProperty();\nd.Add(Name);\n\nAge = model.ObserveProperty(x => x.Age)\n    .ToReadOnlyReactiveProperty();\nd.Add(Age);\n\n// dispose all\nd.Dispose();  AddTo extension method's sample code:  // init\nvar d = new CompositeDisposable();\n\nName = model.ObserveProperty(x => x.Name)\n    .ToReadOnlyReactiveProperty()\n    .AddTo(d);\n\nAge = model.ObserveProperty(x => x.Age)\n    .ToReadOnlyReactiveProperty()\n    .AddTo(d);\n\n// dispose all\nd.Dispose();  It's very cool!",
            "title": "AddTo"
        },
        {
            "location": "/features/Extension-methods/#catchignore",
            "text": "This is that catch exception and return Observable.Empty.  source.CatchIgnore((Exception ex) => { ... error action ... })\n    .Subscribe();",
            "title": "CatchIgnore"
        },
        {
            "location": "/features/Extension-methods/#combinelatestsvaluesareallxxxx",
            "text": "Provides two methods.   CombineLatestValuesAreAllTrue  CombineLatestValuesAreAllFalse   This is just shortcuts, see below.  /// <summary>\n/// Lastest values of each sequence are all true.\n/// </summary>\npublic static IObservable<bool> CombineLatestValuesAreAllTrue(\n    this IEnumerable<IObservable<bool>> sources) => \n    sources.CombineLatest(xs => xs.All(x => x));\n\n\n/// <summary>\n/// Lastest values of each sequence are all false.\n/// </summary>\npublic static IObservable<bool> CombineLatestValuesAreAllFalse(\n    this IEnumerable<IObservable<bool>> sources) =>\n    sources.CombineLatest(xs => xs.All(x => !x));",
            "title": "CombineLatestsValuesAreAllXXXX"
        },
        {
            "location": "/features/Extension-methods/#canexecutechangedasobservable",
            "text": "This is a extension method of ICommand interface.\nIt is a shortcut the  Observable.FromEvent .  /// <summary>Converts CanExecuteChanged to an observable sequence.</summary>\npublic static IObservable<EventArgs> CanExecuteChangedAsObservable<T>(this T source)\n    where T : ICommand =>\n    Observable.FromEvent<EventHandler, EventArgs>(\n        h => (sender, e) => h(e),\n        h => source.CanExecuteChanged += h,\n        h => source.CanExecuteChanged -= h);",
            "title": "CanExecuteChangedAsObservable"
        },
        {
            "location": "/features/Extension-methods/#inotifycollectionchanged-extension-methods",
            "text": "Convert CollectionChanged event to IObservable.  /// <summary>Observe CollectionChanged:Remove and take single item.</summary>\npublic static IObservable<T> ObserveRemoveChanged<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Remove)\n        .Select(e => (T)e.OldItems[0]);\n\n/// <summary>Observe CollectionChanged:Remove.</summary>\npublic static IObservable<T[]> ObserveRemoveChangedItems<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Remove)\n        .Select(e => e.OldItems.Cast<T>().ToArray());\n\n/// <summary>Observe CollectionChanged:Move and take single item.</summary>\npublic static IObservable<OldNewPair<T>> ObserveMoveChanged<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Move)\n        .Select(e => new OldNewPair<T>((T)e.OldItems[0], (T)e.NewItems[0]));\n\n/// <summary>Observe CollectionChanged:Move.</summary>\npublic static IObservable<OldNewPair<T[]>> ObserveMoveChangedItems<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Move)\n        .Select(e => new OldNewPair<T[]>(e.OldItems.Cast<T>().ToArray(), e.NewItems.Cast<T>().ToArray()));\n\n/// <summary>Observe CollectionChanged:Replace and take single item.</summary>\npublic static IObservable<OldNewPair<T>> ObserveReplaceChanged<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Replace)\n        .Select(e => new OldNewPair<T>((T)e.OldItems[0], (T)e.NewItems[0]));\n\n/// <summary>Observe CollectionChanged:Replace.</summary>\npublic static IObservable<OldNewPair<T[]>> ObserveReplaceChangedItems<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Replace)\n        .Select(e => new OldNewPair<T[]>(e.OldItems.Cast<T>().ToArray(), e.NewItems.Cast<T>().ToArray()));\n\n/// <summary>Observe CollectionChanged:Reset.</summary>\npublic static IObservable<Unit> ObserveResetChanged<T>(this INotifyCollectionChanged source) =>\n    source.CollectionChangedAsObservable()\n        .Where(e => e.Action == NotifyCollectionChangedAction.Reset)\n        .Select(_ => new Unit());",
            "title": "INotifyCollectionChanged extension methods"
        },
        {
            "location": "/features/Extension-methods/#observablecollection-extension-methods",
            "text": "It is typesafe version INotifyPropertyChanged extension methods.  /// <summary>Observe CollectionChanged:Add and take single item.</summary>\npublic static IObservable<T> ObserveAddChanged<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveAddChanged<T>();\n\n/// <summary>Observe CollectionChanged:Add.</summary>\npublic static IObservable<T[]> ObserveAddChangedItems<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveAddChangedItems<T>();\n\n/// <summary>Observe CollectionChanged:Remove and take single item.</summary>\npublic static IObservable<T> ObserveRemoveChanged<T>(this ObservableCollection<T> source) =>\n     ((INotifyCollectionChanged)source).ObserveRemoveChanged<T>();\n\n/// <summary>Observe CollectionChanged:Remove.</summary>\npublic static IObservable<T[]> ObserveRemoveChangedItems<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveRemoveChangedItems<T>();\n\n/// <summary>Observe CollectionChanged:Move and take single item.</summary>\npublic static IObservable<OldNewPair<T>> ObserveMoveChanged<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveMoveChanged<T>();\n\n/// <summary>Observe CollectionChanged:Move.</summary>\npublic static IObservable<OldNewPair<T[]>> ObserveMoveChangedItems<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveMoveChangedItems<T>();\n\n/// <summary>Observe CollectionChanged:Replace and take single item.</summary>\npublic static IObservable<OldNewPair<T>> ObserveReplaceChanged<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveReplaceChanged<T>();\n\n/// <summary>Observe CollectionChanged:Replace.</summary>\npublic static IObservable<OldNewPair<T[]>> ObserveReplaceChangedItems<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveReplaceChangedItems<T>();\n\n/// <summary>Observe CollectionChanged:Reset.</summary>\npublic static IObservable<Unit> ObserveResetChanged<T>(this ObservableCollection<T> source) =>\n    ((INotifyCollectionChanged)source).ObserveResetChanged<T>();",
            "title": "ObservableCollection extension methods"
        },
        {
            "location": "/features/Extension-methods/#observe-propertychanged-events-of-observablecollections-items",
            "text": "Watch PropertyChanged event of ObservableCollection's items. \nObserveElementProperty extension method can ovserve specific property's PropertyChanged event.  using Reactive.Bindings.Extensions;\nusing System;\nusing System.Collections.ObjectModel;\nusing System.ComponentModel;\n\nnamespace ReactivePropertyEduApp\n{\n    public class Person : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        private string _name;\n        public string Name\n        {\n            get => _name;\n            set\n            {\n                _name = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n            }\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var c = new ObservableCollection<Person>();\n            c.ObserveElementProperty(x => x.Name)\n                .Subscribe(x => Console.WriteLine($\"Subscribe: {x.Instance}, {x.Property.Name}, {x.Value}\"));\n\n            var neuecc = new Person { Name = \"neuecc\" };\n            var xin9le = new Person { Name = \"xin9le\" };\n            var okazuki = new Person { Name = \"okazuki\" };\n\n            Console.WriteLine(\"Add items\");\n            c.Add(neuecc);\n            c.Add(xin9le);\n            c.Add(okazuki);\n\n            Console.WriteLine(\"Change okazuki name to Kazuki Ota\");\n            okazuki.Name = \"Kazuki Ota\";\n\n            Console.WriteLine(\"Remove okazuki from collection\");\n            c.Remove(okazuki);\n\n            Console.WriteLine(\"Change okazuki name to okazuki\");\n            okazuki.Name = \"okazuki\";\n        }\n    }\n}  Add items\nSubscribe: ReactivePropertyEduApp.Person, Name, neuecc\nSubscribe: ReactivePropertyEduApp.Person, Name, xin9le\nSubscribe: ReactivePropertyEduApp.Person, Name, okazuki\nChange okazuki name to Kazuki Ota\nSubscribe: ReactivePropertyEduApp.Person, Name, Kazuki Ota\nRemove okazuki from collection\nChange okazuki name to okazuki  If target object's property type is ReactiveProperty, then use the ObserveElementPropertyChanged extension method.  using Reactive.Bindings;\nusing Reactive.Bindings.Extensions;\nusing System;\nusing System.Collections.ObjectModel;\nusing System.ComponentModel;\n\nnamespace ReactivePropertyEduApp\n{\n    public class Person\n    {\n        public ReactiveProperty<string> Name { get; }\n\n        public Person(string name)\n        {\n            Name = new ReactiveProperty<string>(name);\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var c = new ObservableCollection<Person>();\n            c.ObserveElementObservableProperty(x => x.Name)\n                .Subscribe(x => Console.WriteLine($\"Subscribe: {x.Instance}, {x.Property.Name}, {x.Value}\"));\n\n            var neuecc = new Person(\"neuecc\");\n            var xin9le = new Person(\"xin9le\");\n            var okazuki = new Person(\"okazuki\");\n\n            Console.WriteLine(\"Add items\");\n            c.Add(neuecc);\n            c.Add(xin9le);\n            c.Add(okazuki);\n\n            Console.WriteLine(\"Change okazuki name to Kazuki Ota\");\n            okazuki.Name.Value = \"Kazuki Ota\";\n\n            Console.WriteLine(\"Remove okazuki from collection\");\n            c.Remove(okazuki);\n\n            Console.WriteLine(\"Change okazuki name to okazuki\");\n            okazuki.Name.Value = \"okazuki\";\n        }\n    }\n}  Add items\nSubscribe: ReactivePropertyEduApp.Person, Name, neuecc\nSubscribe: ReactivePropertyEduApp.Person, Name, xin9le\nSubscribe: ReactivePropertyEduApp.Person, Name, okazuki\nChange okazuki name to Kazuki Ota\nSubscribe: ReactivePropertyEduApp.Person, Name, Kazuki Ota\nRemove okazuki from collection\nChange okazuki name to okazuki",
            "title": "Observe PropertyChanged events of ObservableCollection's items"
        },
        {
            "location": "/features/Extension-methods/#inotifydataerrorinfo-extension-methods",
            "text": "Convert ErrorChanged event to an IObservable<DataErrorsChangedEventArgs>.\nIt is a shortcut of FromEvent method.  /// <summary>Converts ErrorsChanged to an observable sequence.</summary>\npublic static IObservable<DataErrorsChangedEventArgs> ErrorsChangedAsObservable<T>(this T subject)\n    where T : INotifyDataErrorInfo =>\n    Observable.FromEvent<EventHandler<DataErrorsChangedEventArgs>, DataErrorsChangedEventArgs>(\n        h => (sender, e) => h(e),\n        h => subject.ErrorsChanged += h,\n        h => subject.ErrorsChanged -= h);  ObserveErrorInfo extension method is the version of raise the property value when ErrorChanged event occured.",
            "title": "INotifyDataErrorInfo extension methods"
        },
        {
            "location": "/features/Extension-methods/#inverse",
            "text": "Inverse the boolean value of an IObservable<bool> sequence.  IObservable<bool> boolSequence = ...;\nIObservable<bool> inversedBoolSequence = boolSequence.Inverse();  It is a same as below code.  IObservable<bool> boolSequence = ...;\nIObservable<bool> inversedBoolSequence = boolSequence.Select(x => !x);",
            "title": "Inverse"
        },
        {
            "location": "/features/Event-transfer-to-ViewModel-from-View/",
            "text": "EventToReactiveProperty and EventToReactiveCommand classes transfer event to ReactiveProeprty and ReactiveCommand from View layer.\nThose classes extend TriggerAction. Those are designed that uses together with EventTrigger.\n\n\nNote:\n \n\n\n\n\nThis feature provides to only WPF and UWP.\nXamarin.Forms can't use this feature.\n\n\n\n\nThose classes can convert EventArgs to any types object using ReactiveConverter<T, U>.\n\n\nReactiveConverter class can use Rx method chain. It's very powerful.\n\n\nUWP sample:\n\n\nusing Reactive.Bindings.Interactivity;\nusing System;\nusing System.Linq;\nusing System.Reactive.Linq;\nusing Windows.Storage.Pickers;\nusing Windows.UI.Xaml;\n\nnamespace App1\n{\n    public class FileOpenReactiveConverter : ReactiveConverter<RoutedEventArgs, string>\n    {\n        protected override IObservable<string> OnConvert(IObservable<RoutedEventArgs> source)\n        {\n            return source.SelectMany(async _ =>\n            {\n                var picker = new FileOpenPicker();\n                picker.FileTypeFilter.Add(\".snippet\");\n                var f = await picker.PickSingleFileAsync();\n                return f?.Path;\n            })\n            .Where(x => x != null);\n\n        }\n    }\n}\n\n\n\n\nIt convert RoutedEventArgs to the file path.\n\n\nXAML and Code behind are below.\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      xmlns:i=\"using:Microsoft.Xaml.Interactivity\"\n      xmlns:c=\"using:Microsoft.Xaml.Interactions.Core\"\n      xmlns:reactiveProperty=\"using:Reactive.Bindings.Interactivity\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"OpenFile...\">\n            <i:Interaction.Behaviors>\n                <c:EventTriggerBehavior EventName=\"Click\">\n                    <reactiveProperty:EventToReactiveCommand Command=\"{x:Bind ViewModel.SelectFileCommand}\">\n                        <local:FileOpenReactiveConverter />\n                    </reactiveProperty:EventToReactiveCommand>\n                </c:EventTriggerBehavior>\n            </i:Interaction.Behaviors>\n        </Button>\n        <TextBlock Text=\"{x:Bind ViewModel.FileName.Value, Mode=OneWay}\" />\n    </StackPanel>\n</Page>\n\n\n\n\nusing Reactive.Bindings;\nusing Windows.UI.Xaml.Controls;\n\nnamespace App1\n{\n    public sealed partial class MainPage : Page\n    {\n        public MainPageViewModel ViewModel { get; } = new MainPageViewModel();\n\n        public MainPage()\n        {\n            this.InitializeComponent();\n        }\n    }\n\n    public class MainPageViewModel\n    {\n        public ReactiveCommand<string> SelectFileCommand { get; }\n        public ReadOnlyReactiveProperty<string> FileName { get; }\n\n        public MainPageViewModel()\n        {\n            this.SelectFileCommand = new ReactiveCommand<string>();\n            this.FileName = this.SelectFileCommand.ToReadOnlyReactiveProperty();\n        }\n    }\n\n}\n\n\n\n\n\n\nEventToReactiveProperty sets the value converted by ReactiveConverter to ReactiveProperty.\n\n\n<Page x:Class=\"App1.MainPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:local=\"using:App1\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      xmlns:i=\"using:Microsoft.Xaml.Interactivity\"\n      xmlns:c=\"using:Microsoft.Xaml.Interactions.Core\"\n      xmlns:reactiveProperty=\"using:Reactive.Bindings.Interactivity\"\n      mc:Ignorable=\"d\">\n    <StackPanel Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <Button Content=\"OpenFile...\">\n            <i:Interaction.Behaviors>\n                <c:EventTriggerBehavior EventName=\"Click\">\n                    <reactiveProperty:EventToReactiveProperty ReactiveProperty=\"{x:Bind ViewModel.FileName}\">\n                        <local:FileOpenReactiveConverter />\n                    </reactiveProperty:EventToReactiveProperty>\n                </c:EventTriggerBehavior>\n            </i:Interaction.Behaviors>\n        </Button>\n        <TextBlock Text=\"{x:Bind ViewModel.FileName.Value, Mode=OneWay}\" />\n    </StackPanel>\n</Page>\n\n\n\n\nusing Reactive.Bindings;\nusing Windows.UI.Xaml.Controls;\n\nnamespace App1\n{\n    public sealed partial class MainPage : Page\n    {\n        public MainPageViewModel ViewModel { get; } = new MainPageViewModel();\n\n        public MainPage()\n        {\n            this.InitializeComponent();\n        }\n    }\n\n    public class MainPageViewModel\n    {\n        public ReactiveProperty<string> FileName { get; } = new ReactiveProperty<string>();\n    }\n\n}",
            "title": "Transfer event to ViewModel from View"
        },
        {
            "location": "/advanced/thread/",
            "text": "ReactiveProperty provides execution thread control feature.\nReactiveProperty raise PropertyChanged event on UI thread automaticaly. \n\n\nChange the scheduler\n\n\nYou can change this behavior using IScheduler.\nWhen the instance creation time, set IScheduler instance to raiseEventScheduler argument.\n\n\nvar rp = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ToReactiveProperty(raiseEventScheduler: ImmediateScheduler.Instance);\n\n\n\n\nReactiveCollection and ReadOnlyReactiveCollection raise CollectionChanged event on UI thread same as ReactiveProperty.\nThis behavior can be changed using the scheduler constructor and factory method argument.\n\n\nvar collection = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ToReactiveCollection(scheduler: ImmediateScheduler.Instance);\n\nvar readOnlyCollection = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ToReadOnlyReactiveProperty(scheduler: ImmediateScheduler.Instance);\n\n\n\n\nChange the gloabl scheduler\n\n\nCan change the ReactiveProperty's default scheduler using ReactivePropertyScheduler.SetDefault method.\n\n\nReactivePropertyScheduler.SetDefault(TaskPoolScheduler.Default);\nvar taskPoolRp = new ReactiveProperty<string>();\nReactivePropertyScheduler.SetDefault(ImmediateScheduler.Instance);\nvar immediateRp = new ReactiveProperty<string>();\n\ntaskPoolRp.Value = \"changed\"; // raise event on the TaskPoolScheduler thread.\nimmediateRp.Value = \"changed\"; // raise event on the ImmediateScheduler thread.\n\n\n\n\nRx operator\n\n\nOf cource, you can use ObserveOn extension method.\n\n\nvar rp = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ObserveOn(someScheduler)\n    .ToReactiveProperty();\n\n\n\n\nAnd we provide ObserveOnUIDispatcher extension method. \nThis is a shortcut of \nObserveOn(ReactiveProeprtyScheduler.Default)\n.\n\n\nvar rp = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ObserveOnUIDispatcher()\n    .ToReactiveProperty();\n\n\n\n\nLimitations\n\n\nReactiveProperty was designed for single UI thread platform.\nIt means it doesn't work on the multi UI thread platform which is like UWP platform.\n\n\nUWP has multi UI thread in the single process when multi Window create.\nIf you create multi-window in UWP, then should set ImmediateScheduler to ReactivePropertyScheduler, when the app was launched.\nOr use ReactivePropertySlim / ReadOnlyReactivePropertySlim classes.",
            "title": "Thread control"
        },
        {
            "location": "/advanced/thread/#change-the-scheduler",
            "text": "You can change this behavior using IScheduler.\nWhen the instance creation time, set IScheduler instance to raiseEventScheduler argument.  var rp = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ToReactiveProperty(raiseEventScheduler: ImmediateScheduler.Instance);  ReactiveCollection and ReadOnlyReactiveCollection raise CollectionChanged event on UI thread same as ReactiveProperty.\nThis behavior can be changed using the scheduler constructor and factory method argument.  var collection = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ToReactiveCollection(scheduler: ImmediateScheduler.Instance);\n\nvar readOnlyCollection = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ToReadOnlyReactiveProperty(scheduler: ImmediateScheduler.Instance);",
            "title": "Change the scheduler"
        },
        {
            "location": "/advanced/thread/#change-the-gloabl-scheduler",
            "text": "Can change the ReactiveProperty's default scheduler using ReactivePropertyScheduler.SetDefault method.  ReactivePropertyScheduler.SetDefault(TaskPoolScheduler.Default);\nvar taskPoolRp = new ReactiveProperty<string>();\nReactivePropertyScheduler.SetDefault(ImmediateScheduler.Instance);\nvar immediateRp = new ReactiveProperty<string>();\n\ntaskPoolRp.Value = \"changed\"; // raise event on the TaskPoolScheduler thread.\nimmediateRp.Value = \"changed\"; // raise event on the ImmediateScheduler thread.",
            "title": "Change the gloabl scheduler"
        },
        {
            "location": "/advanced/thread/#rx-operator",
            "text": "Of cource, you can use ObserveOn extension method.  var rp = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ObserveOn(someScheduler)\n    .ToReactiveProperty();  And we provide ObserveOnUIDispatcher extension method. \nThis is a shortcut of  ObserveOn(ReactiveProeprtyScheduler.Default) .  var rp = Observable.Interval(TimeSpan.FromSeconds(1))\n    .ObserveOnUIDispatcher()\n    .ToReactiveProperty();",
            "title": "Rx operator"
        },
        {
            "location": "/advanced/thread/#limitations",
            "text": "ReactiveProperty was designed for single UI thread platform.\nIt means it doesn't work on the multi UI thread platform which is like UWP platform.  UWP has multi UI thread in the single process when multi Window create.\nIf you create multi-window in UWP, then should set ImmediateScheduler to ReactivePropertyScheduler, when the app was launched.\nOr use ReactivePropertySlim / ReadOnlyReactivePropertySlim classes.",
            "title": "Limitations"
        },
        {
            "location": "/samples/",
            "text": "Sample programs see below:\n\n\nWPF sample\n\n\nMVVM pattern and Reactive programming sample\n\n\nUWP sample\n\n\nUWPTodoMVVM project in Sample folder\n is like \nTodoMVC\n todo application.",
            "title": "Samples"
        },
        {
            "location": "/samples/#wpf-sample",
            "text": "MVVM pattern and Reactive programming sample",
            "title": "WPF sample"
        },
        {
            "location": "/samples/#uwp-sample",
            "text": "UWPTodoMVVM project in Sample folder  is like  TodoMVC  todo application.",
            "title": "UWP sample"
        }
    ]
}